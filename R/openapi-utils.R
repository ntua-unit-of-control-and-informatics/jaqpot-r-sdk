#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' ApiClient Class
#'
#' Generic API client for OpenAPI client library builds.
#' OpenAPI generic API client. This client handles the client-
#' server communication, and is invariant across implementations. Specifics of
#' the methods and models for each application are generated from the OpenAPI Generator
#' templates.
#'
#' NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
#' Ref: https://openapi-generator.tech
#' Do not edit the class manually.
#'
#' @docType class
#' @title ApiClient
#' @description ApiClient Class
#' @format An \code{R6Class} generator object
#' @field base_path Base url
#' @field user_agent Default user agent
#' @field default_headers Default headers
#' @field username Username for HTTP basic authentication
#' @field password Password for HTTP basic authentication
#' @field api_keys API keys
#' @field bearer_token Bearer token
#' @field timeout Default timeout in seconds
#' @field retry_status_codes vector of status codes to retry
#' @field max_retry_attempts maximum number of retries for the status codes
#' @importFrom httr add_headers accept timeout content
#' @keywords internal 
#' @noRd
NULL
ApiClient <- R6::R6Class(
  "ApiClient",
  public = list(
    # base path of all requests
    base_path = "https://api.jaqpot.org",
    # user agent in the HTTP request
    user_agent = "OpenAPI-Generator/1.0.0/r",
    # default headers in the HTTP request
    default_headers = NULL,
    # username (HTTP basic authentication)
    username = NULL,
    # password (HTTP basic authentication)
    password = NULL,
    # API keys
    api_keys = NULL,
    # Bearer token
    bearer_token = NULL,
    # Time Out (seconds)
    timeout = NULL,
    # Vector of status codes to retry
    retry_status_codes = NULL,
    # Maximum number of retry attempts for the retry status codes
    max_retry_attempts = NULL,
    #' Initialize a new ApiClient.
    #'
    #' @description
    #' Initialize a new ApiClient.
    #'
    #' @param base_path Base path.
    #' @param user_agent User agent.
    #' @param default_headers Default headers.
    #' @param username User name.
    #' @param password Password.
    #' @param api_keys API keys.
    #' @param access_token Access token.
    #' @param bearer_token Bearer token.
    #' @param timeout Timeout.
    #' @param retry_status_codes Status codes for retry.
    #' @param max_retry_attempts Maxmium number of retry.
    #' @keywords internal 
    #' @noRd
    initialize = function(base_path = NULL, user_agent = NULL,
                          default_headers = NULL,
                          username = NULL, password = NULL, api_keys = NULL,
                          access_token = NULL, bearer_token = NULL, timeout = NULL,
                          retry_status_codes = NULL, max_retry_attempts = NULL) {
      if (!is.null(base_path)) {
        self$base_path <- base_path
      }
      
      if (!is.null(default_headers)) {
        self$default_headers <- default_headers
      }
      
      if (!is.null(username)) {
        self$username <- username
      }
      
      if (!is.null(password)) {
        self$password <- password
      }
      
      if (!is.null(access_token)) {
        self$access_token <- access_token
      }
      
      if (!is.null(bearer_token)) {
        self$bearer_token <- bearer_token
      }
      
      if (!is.null(api_keys)) {
        self$api_keys <- api_keys
      } else {
        self$api_keys <- list()
      }
      
      if (!is.null(user_agent)) {
        self$`user_agent` <- user_agent
      }
      
      if (!is.null(timeout)) {
        self$timeout <- timeout
      }
      
      if (!is.null(retry_status_codes)) {
        self$retry_status_codes <- retry_status_codes
      }
      
      if (!is.null(max_retry_attempts)) {
        self$max_retry_attempts <- max_retry_attempts
      }
    },
    
    #' @description
    #' Prepare to make an API call with the retry logic.
    #'
    #' @param url URL.
    #' @param method HTTP method.
    #' @param query_params The query parameters.
    #' @param header_params The header parameters.
    #' @param form_params The form parameters.
    #' @param file_params The form parameters for uploading files.
    #' @param accepts The list of Accept headers.
    #' @param content_types The list of Content-Type headers.
    #' @param body The HTTP request body.
    #' @param stream_callback Callback function to process the data stream
    #' @param ... Other optional arguments.
    #'
    #' @return HTTP response
    CallApi = function(url, method, query_params, header_params, form_params,
                       file_params, accepts, content_types,
                       body, stream_callback = NULL, ...) {
      
      resp <- self$Execute(url, method, query_params, header_params,
                           form_params, file_params,
                           accepts, content_types,
                           body, stream_callback = stream_callback, ...)
      
      if (is.null(self$max_retry_attempts)) {
        self$max_retry_attempts <- 3
      }
      
      if (!is.null(self$retry_status_codes)) {
        
        for (i in 1 : self$max_retry_attempts) {
          if (resp$status_code %in% self$retry_status_codes) {
            Sys.sleep((2 ^ i) + stats::runif(n = 1, min = 0, max = 1))
            resp <- self$Execute(url, method, query_params, header_params,
                                 form_params, file_params, accepts, content_types,
                                 body, stream_callback = stream_callback, ...)
          } else {
            break
          }
        }
      }
      
      resp
    },
    
    #' @description
    #' Make an API call
    #'
    #' @param url URL.
    #' @param method HTTP method.
    #' @param query_params The query parameters.
    #' @param header_params The header parameters.
    #' @param form_params The form parameters.
    #' @param file_params The form parameters for uploading files.
    #' @param accepts The list of Accept headers
    #' @param content_types The list of Content-Type headers
    #' @param body The HTTP request body.
    #' @param stream_callback Callback function to process data stream
    #' @param ... Other optional arguments.
    #'
    #' @return HTTP response
    Execute = function(url, method, query_params, header_params,
                       form_params, file_params,
                       accepts, content_types,
                       body, stream_callback = NULL, ...) {
      headers <- httr::add_headers(c(header_params, self$default_headers))
      
      http_timeout <- NULL
      if (!is.null(self$timeout)) {
        http_timeout <- httr::timeout(self$timeout)
      }
      
      # set HTTP accept header
      accept = self$select_header(accepts)
      if (!is.null(accept)) {
        headers['Accept'] = accept
      }
      
      # set HTTP content-type header
      content_type = self$select_header(content_types)
      if (!is.null(content_type)) {
        headers['Content-Type'] = content_type
      }
      
      if (typeof(stream_callback) == "closure") { # stream data
        if (method == "GET") {
          httr::GET(url, query = query_params, headers, http_timeout,
                    httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "POST") {
          httr::POST(url, query = query_params, headers, body = body,
                     httr::content_type("application/json"), http_timeout,
                     httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "PUT") {
          httr::PUT(url, query = query_params, headers, body = body,
                    httr::content_type("application/json"), http_timeout,
                    http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "PATCH") {
          httr::PATCH(url, query = query_params, headers, body = body,
                      httr::content_type("application/json"), http_timeout,
                      http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "HEAD") {
          httr::HEAD(url, query = query_params, headers, http_timeout,
                     http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else if (method == "DELETE") {
          httr::DELETE(url, query = query_params, headers, http_timeout,
                       http_timeout, httr::user_agent(self$`user_agent`), write_stream(stream_callback), ...)
        } else {
          err_msg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
          stop(err_msg)
        }
      } else { # no streaming
        if (method == "GET") {
          httr_response <- httr::GET(url, query = query_params, headers, http_timeout,
                                     httr::user_agent(self$`user_agent`), ...)
        } else if (method == "POST") {
          httr_response <- httr::POST(url, query = query_params, headers, body = body,
                                      httr::content_type("application/json"), http_timeout,
                                      httr::user_agent(self$`user_agent`), ...)
        } else if (method == "PUT") {
          httr_response <- httr::PUT(url, query = query_params, headers, body = body,
                                     httr::content_type("application/json"), http_timeout,
                                     http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "PATCH") {
          httr_response <- httr::PATCH(url, query = query_params, headers, body = body,
                                       httr::content_type("application/json"), http_timeout,
                                       http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "HEAD") {
          httr_response <- httr::HEAD(url, query = query_params, headers, http_timeout,
                                      http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else if (method == "DELETE") {
          httr_response <- httr::DELETE(url, query = query_params, headers, http_timeout,
                                        http_timeout, httr::user_agent(self$`user_agent`), ...)
        } else {
          err_msg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
          stop(err_msg)
        }
        
        # return ApiResponse
        api_response <- ApiResponse$new()
        api_response$status_code <- httr::status_code(httr_response)
        api_response$status_code_desc <- httr::http_status(httr_response)$reason
        api_response$response <- httr::content(httr_response, "raw")
        api_response$headers <- httr::headers(httr_response)
        
        api_response
      }
    },
    
    #' @description
    #' Deserialize the content of API response to the given type.
    #'
    #' @param raw_response Raw response.
    #' @param return_type R return type.
    #' @param pkg_env Package environment.
    #'
    #' @return Deserialized object.
    deserialize = function(raw_response, return_type, pkg_env) {
      resp_obj <- jsonlite::fromJSON(raw_response)
      self$deserializeObj(resp_obj, return_type, pkg_env)
    },
    
    #' @description
    #' Deserialize the response from jsonlite object based on the given type
    #' by handling complex and nested types by iterating recursively
    #' Example return_types will be like "array[integer]", "map(Pet)",
    #' "array[map(Tag)]", etc.,
    #'
    #' @param obj Response object.
    #' @param return_type R return type.
    #' @param pkg_env Package environment.
    #'
    #' @return Deserialized object.
    deserializeObj = function(obj, return_type, pkg_env) {
      return_obj <- NULL
      primitive_types <- c("character", "numeric", "integer", "logical", "complex")
      
      # To handle the "map" type
      if (startsWith(return_type, "map(")) {
        inner_return_type <- regmatches(return_type,
                                        regexec(pattern = "map\\((.*)\\)", return_type))[[1]][2]
        return_obj <- lapply(names(obj), function(name) {
          self$deserializeObj(obj[[name]], inner_return_type, pkg_env)
        })
        names(return_obj) <- names(obj)
      } else if (startsWith(return_type, "array[")) {
        # To handle the "array" type
        inner_return_type <- regmatches(return_type,
                                        regexec(pattern = "array\\[(.*)\\]", return_type))[[1]][2]
        if (c(inner_return_type) %in% primitive_types) {
          return_obj <- vector("list", length = length(obj))
          if (length(obj) > 0) {
            for (row in 1:length(obj)) {
              return_obj[[row]] <- self$deserializeObj(obj[row], inner_return_type, pkg_env)
            }
          }
        } else {
          if (!is.null(nrow(obj))) {
            return_obj <- vector("list", length = nrow(obj))
            if (nrow(obj) > 0) {
              for (row in 1:nrow(obj)) {
                return_obj[[row]] <- self$deserializeObj(obj[row, , drop = FALSE],
                                                         inner_return_type, pkg_env)
              }
            }
          }
        }
      } else if (exists(return_type, pkg_env) && !(c(return_type) %in% primitive_types)) {
        # To handle model objects which are not array or map containers. Ex:"Pet"
        return_type <- get(return_type, envir = as.environment(pkg_env))
        return_obj <- return_type$new()
        # check if discriminator is defined
        if (!is.null(return_obj$`_discriminator_property_name`)) {
          data_type <- return_obj$`_discriminator_property_name`
          # use discriminator mapping if provided
          if (!is.null(return_obj$`_discriminator_mapping_name`)) {
            data_type <- (return_obj$`_discriminator_mapping_name`)[[obj[[data_type]]]]
          } else {
            # no mapping provided, use the value directly
            data_type <- obj[[data_type]]
          }
          # create an object of the mapped type (e.g. Cat)
          return_type <- get(data_type, envir = as.environment(pkg_env))
          return_obj <- return_type$new()
        }
        return_obj$fromJSON(
          jsonlite::toJSON(obj, digits = NA, auto_unbox = TRUE)
        )
      } else {
        # To handle primitive type
        return_obj <- obj
      }
      return_obj
    },
    
    #' @description
    #' Return a property header (for accept or content-type). If JSON-related MIME is found,
    #' return it. Otherwise, return the first one, if any.
    #'
    #' @param headers A list of headers
    #'
    #' @return A header (e.g. 'application/json')
    select_header = function(headers) {
      if (length(headers) == 0) {
        return(invisible(NULL))
      } else {
        for (header in headers) {
          if (stringr::str_detect(header, "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$")) {
            # return JSON-related MIME
            return(header)
          }
        }
        
        # not json mime type, simply return the first one
        return(headers[1])
      }
    }
  )
)


#' Create a new ApiKey
#'
#' @description
#' ApiKey Class
#'
#' @docType class
#' @title ApiKey
#' @description ApiKey Class
#' @format An \code{R6Class} generator object
#' @field clientKey The generated API key character [optional]
#' @field note A note for the API key character [optional]
#' @field userId The ID of the user associated with the API key character [optional]
#' @field expiresAt The expiration time of the API key (if any) character [optional]
#' @field expirationTime  character
#' @field lastUsed The last time the API key was used character [optional]
#' @field lastUsedIp The IP address from which the API key was last used character [optional]
#' @field enabled Whether the API key is active or disabled character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
ApiKey <- R6::R6Class(
  "ApiKey",
  public = list(
    `clientKey` = NULL,
    `note` = NULL,
    `userId` = NULL,
    `expiresAt` = NULL,
    `expirationTime` = NULL,
    `lastUsed` = NULL,
    `lastUsedIp` = NULL,
    `enabled` = NULL,
    
    #' @description
    #' Initialize a new ApiKey class.
    #'
    #' @param expirationTime expirationTime
    #' @param clientKey The generated API key
    #' @param note A note for the API key
    #' @param userId The ID of the user associated with the API key
    #' @param expiresAt The expiration time of the API key (if any)
    #' @param lastUsed The last time the API key was used
    #' @param lastUsedIp The IP address from which the API key was last used
    #' @param enabled Whether the API key is active or disabled
    #' @param ... Other optional arguments.
    initialize = function(`expirationTime`, `clientKey` = NULL, `note` = NULL, `userId` = NULL, `expiresAt` = NULL, `lastUsed` = NULL, `lastUsedIp` = NULL, `enabled` = NULL, ...) {
      if (!missing(`expirationTime`)) {
        if (!(`expirationTime` %in% c("THREE_MONTHS", "SIX_MONTHS"))) {
          stop(paste("Error! \"", `expirationTime`, "\" cannot be assigned to `expirationTime`. Must be \"THREE_MONTHS\", \"SIX_MONTHS\".", sep = ""))
        }
        if (!(is.character(`expirationTime`) && length(`expirationTime`) == 1)) {
          stop(paste("Error! Invalid data for `expirationTime`. Must be a string:", `expirationTime`))
        }
        self$`expirationTime` <- `expirationTime`
      }
      if (!is.null(`clientKey`)) {
        if (!(is.character(`clientKey`) && length(`clientKey`) == 1)) {
          stop(paste("Error! Invalid data for `clientKey`. Must be a string:", `clientKey`))
        }
        self$`clientKey` <- `clientKey`
      }
      if (!is.null(`note`)) {
        if (!(is.character(`note`) && length(`note`) == 1)) {
          stop(paste("Error! Invalid data for `note`. Must be a string:", `note`))
        }
        self$`note` <- `note`
      }
      if (!is.null(`userId`)) {
        if (!(is.character(`userId`) && length(`userId`) == 1)) {
          stop(paste("Error! Invalid data for `userId`. Must be a string:", `userId`))
        }
        self$`userId` <- `userId`
      }
      if (!is.null(`expiresAt`)) {
        if (!is.character(`expiresAt`)) {
          stop(paste("Error! Invalid data for `expiresAt`. Must be a string:", `expiresAt`))
        }
        self$`expiresAt` <- `expiresAt`
      }
      if (!is.null(`lastUsed`)) {
        if (!is.character(`lastUsed`)) {
          stop(paste("Error! Invalid data for `lastUsed`. Must be a string:", `lastUsed`))
        }
        self$`lastUsed` <- `lastUsed`
      }
      if (!is.null(`lastUsedIp`)) {
        if (!(is.character(`lastUsedIp`) && length(`lastUsedIp`) == 1)) {
          stop(paste("Error! Invalid data for `lastUsedIp`. Must be a string:", `lastUsedIp`))
        }
        self$`lastUsedIp` <- `lastUsedIp`
      }
      if (!is.null(`enabled`)) {
        if (!(is.logical(`enabled`) && length(`enabled`) == 1)) {
          stop(paste("Error! Invalid data for `enabled`. Must be a boolean:", `enabled`))
        }
        self$`enabled` <- `enabled`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ApiKey in JSON format
    toJSON = function() {
      ApiKeyObject <- list()
      if (!is.null(self$`clientKey`)) {
        ApiKeyObject[["clientKey"]] <-
          self$`clientKey`
      }
      if (!is.null(self$`note`)) {
        ApiKeyObject[["note"]] <-
          self$`note`
      }
      if (!is.null(self$`userId`)) {
        ApiKeyObject[["userId"]] <-
          self$`userId`
      }
      if (!is.null(self$`expiresAt`)) {
        ApiKeyObject[["expiresAt"]] <-
          self$`expiresAt`
      }
      if (!is.null(self$`expirationTime`)) {
        ApiKeyObject[["expirationTime"]] <-
          self$`expirationTime`
      }
      if (!is.null(self$`lastUsed`)) {
        ApiKeyObject[["lastUsed"]] <-
          self$`lastUsed`
      }
      if (!is.null(self$`lastUsedIp`)) {
        ApiKeyObject[["lastUsedIp"]] <-
          self$`lastUsedIp`
      }
      if (!is.null(self$`enabled`)) {
        ApiKeyObject[["enabled"]] <-
          self$`enabled`
      }
      ApiKeyObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ApiKey
    #'
    #' @param input_json the JSON input
    #' @return the instance of ApiKey
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`clientKey`)) {
        self$`clientKey` <- this_object$`clientKey`
      }
      if (!is.null(this_object$`note`)) {
        self$`note` <- this_object$`note`
      }
      if (!is.null(this_object$`userId`)) {
        self$`userId` <- this_object$`userId`
      }
      if (!is.null(this_object$`expiresAt`)) {
        self$`expiresAt` <- this_object$`expiresAt`
      }
      if (!is.null(this_object$`expirationTime`)) {
        if (!is.null(this_object$`expirationTime`) && !(this_object$`expirationTime` %in% c("THREE_MONTHS", "SIX_MONTHS"))) {
          stop(paste("Error! \"", this_object$`expirationTime`, "\" cannot be assigned to `expirationTime`. Must be \"THREE_MONTHS\", \"SIX_MONTHS\".", sep = ""))
        }
        self$`expirationTime` <- this_object$`expirationTime`
      }
      if (!is.null(this_object$`lastUsed`)) {
        self$`lastUsed` <- this_object$`lastUsed`
      }
      if (!is.null(this_object$`lastUsedIp`)) {
        self$`lastUsedIp` <- this_object$`lastUsedIp`
      }
      if (!is.null(this_object$`enabled`)) {
        self$`enabled` <- this_object$`enabled`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ApiKey in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`clientKey`)) {
          sprintf(
            '"clientKey":
            "%s"
                    ',
            self$`clientKey`
          )
        },
        if (!is.null(self$`note`)) {
          sprintf(
            '"note":
            "%s"
                    ',
            self$`note`
          )
        },
        if (!is.null(self$`userId`)) {
          sprintf(
            '"userId":
            "%s"
                    ',
            self$`userId`
          )
        },
        if (!is.null(self$`expiresAt`)) {
          sprintf(
            '"expiresAt":
            "%s"
                    ',
            self$`expiresAt`
          )
        },
        if (!is.null(self$`expirationTime`)) {
          sprintf(
            '"expirationTime":
            "%s"
                    ',
            self$`expirationTime`
          )
        },
        if (!is.null(self$`lastUsed`)) {
          sprintf(
            '"lastUsed":
            "%s"
                    ',
            self$`lastUsed`
          )
        },
        if (!is.null(self$`lastUsedIp`)) {
          sprintf(
            '"lastUsedIp":
            "%s"
                    ',
            self$`lastUsedIp`
          )
        },
        if (!is.null(self$`enabled`)) {
          sprintf(
            '"enabled":
            %s
                    ',
            tolower(self$`enabled`)
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ApiKey
    #'
    #' @param input_json the JSON input
    #' @return the instance of ApiKey
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`clientKey` <- this_object$`clientKey`
      self$`note` <- this_object$`note`
      self$`userId` <- this_object$`userId`
      self$`expiresAt` <- this_object$`expiresAt`
      if (!is.null(this_object$`expirationTime`) && !(this_object$`expirationTime` %in% c("THREE_MONTHS", "SIX_MONTHS"))) {
        stop(paste("Error! \"", this_object$`expirationTime`, "\" cannot be assigned to `expirationTime`. Must be \"THREE_MONTHS\", \"SIX_MONTHS\".", sep = ""))
      }
      self$`expirationTime` <- this_object$`expirationTime`
      self$`lastUsed` <- this_object$`lastUsed`
      self$`lastUsedIp` <- this_object$`lastUsedIp`
      self$`enabled` <- this_object$`enabled`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to ApiKey and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `expirationTime`
      if (!is.null(input_json$`expirationTime`)) {
        if (!(is.character(input_json$`expirationTime`) && length(input_json$`expirationTime`) == 1)) {
          stop(paste("Error! Invalid data for `expirationTime`. Must be a string:", input_json$`expirationTime`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ApiKey: the required field `expirationTime` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ApiKey
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `expirationTime` is null
      if (is.null(self$`expirationTime`)) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `expirationTime` is null
      if (is.null(self$`expirationTime`)) {
        invalid_fields["expirationTime"] <- "Non-nullable required field `expirationTime` cannot be null."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# ApiKey$unlock()
#
## Below is an example to define the print function
# ApiKey$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# ApiKey$lock()

#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title ApiKeys operations
#' @description ApiKeysApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateApiKey  ####################
#'
#' library(openapi)
#' var_api_key <- ApiKey$new("THREE_MONTHS", "clientKey_example", "note_example", "userId_example", "expiresAt_example", "lastUsed_example", "lastUsedIp_example", "enabled_example") # ApiKey | Payload to create a new API key
#'
#' #Create an API Key for the User
#' api_instance <- ApiKeysApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateApiKey(var_api_keydata_file = "result.txt")
#' result <- api_instance$CreateApiKey(var_api_key)
#' dput(result)
#'
#'
#' ####################  DeleteApiKey  ####################
#'
#' library(openapi)
#' var_key <- "jq_abcd1234efgh5678ijkl" # character | The API key to delete
#'
#' #Delete an API Key
#' api_instance <- ApiKeysApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$DeleteApiKey(var_key)
#'
#'
#' ####################  GetAllApiKeysForUser  ####################
#'
#' library(openapi)
#'
#' #Get All API Keys for the User
#' api_instance <- ApiKeysApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAllApiKeysForUser(data_file = "result.txt")
#' result <- api_instance$GetAllApiKeysForUser()
#' dput(result)
#'
#'
#' ####################  UpdateApiKey  ####################
#'
#' library(openapi)
#' var_key <- "jq_abcd1234efgh5678ijkl" # character | The API key to update
#' var_update_api_key_request <- updateApiKey_request$new("note_example", "enabled_example") # UpdateApiKeyRequest | Payload to update API key metadata
#'
#' #Update API Key
#' api_instance <- ApiKeysApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateApiKey(var_key, var_update_api_key_requestdata_file = "result.txt")
#' result <- api_instance$UpdateApiKey(var_key, var_update_api_key_request)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
#' @noRd
ApiKeysApi <- R6::R6Class(
  "ApiKeysApi",
  public = list(
    api_client = NULL,
    
    #' @description
    #' Initialize a new ApiKeysApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    
    #' @description
    #' Create an API Key for the User
    #'
    #' @param api_key Payload to create a new API key
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return CreateApiKey201Response
    CreateApiKey = function(api_key, data_file = NULL, ...) {
      local_var_response <- self$CreateApiKeyWithHttpInfo(api_key, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Create an API Key for the User
    #'
    #' @param api_key Payload to create a new API key
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (CreateApiKey201Response) with additional information such as HTTP status code, headers
    CreateApiKeyWithHttpInfo = function(api_key, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`api_key`)) {
        stop("Missing required parameter `api_key`.")
      }
      
      
      if (!is.null(`api_key`)) {
        local_var_body <- `api_key`$toJSONString()
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/user/api-keys"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "POST",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "CreateApiKey201Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Delete an API Key
    #'
    #' @param key The API key to delete
    #' @param ... Other optional arguments
    #'
    #' @return void
    DeleteApiKey = function(key, ...) {
      local_var_response <- self$DeleteApiKeyWithHttpInfo(key, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Delete an API Key
    #'
    #' @param key The API key to delete
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    DeleteApiKeyWithHttpInfo = function(key, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`key`)) {
        stop("Missing required parameter `key`.")
      }
      
      
      local_var_url_path <- "/v1/user/api-keys/{key}"
      if (!missing(`key`)) {
        local_var_url_path <- gsub("\\{key\\}", URLencode(as.character(`key`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "DELETE",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Get All API Keys for the User
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return array[GetAllApiKeysForUser200ResponseInner]
    GetAllApiKeysForUser = function(data_file = NULL, ...) {
      local_var_response <- self$GetAllApiKeysForUserWithHttpInfo(data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get All API Keys for the User
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (array[GetAllApiKeysForUser200ResponseInner]) with additional information such as HTTP status code, headers
    GetAllApiKeysForUserWithHttpInfo = function(data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      local_var_url_path <- "/v1/user/api-keys"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "array[GetAllApiKeysForUser200ResponseInner]", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Update API Key
    #'
    #' @param key The API key to update
    #' @param update_api_key_request Payload to update API key metadata
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UpdateApiKey200Response
    UpdateApiKey = function(key, update_api_key_request, data_file = NULL, ...) {
      local_var_response <- self$UpdateApiKeyWithHttpInfo(key, update_api_key_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Update API Key
    #'
    #' @param key The API key to update
    #' @param update_api_key_request Payload to update API key metadata
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UpdateApiKey200Response) with additional information such as HTTP status code, headers
    UpdateApiKeyWithHttpInfo = function(key, update_api_key_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`key`)) {
        stop("Missing required parameter `key`.")
      }
      
      if (missing(`update_api_key_request`)) {
        stop("Missing required parameter `update_api_key_request`.")
      }
      
      
      
      if (!is.null(`update_api_key_request`)) {
        local_var_body <- `update_api_key_request`$toJSONString()
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/user/api-keys/{key}"
      if (!missing(`key`)) {
        local_var_url_path <- gsub("\\{key\\}", URLencode(as.character(`key`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "PATCH",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "UpdateApiKey200Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)


#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title ApiResponse
#' @description ApiResponse Class
#' @format An \code{R6Class} generator object
#' @field content The deserialized response body.
#' @field response The raw response from the endpoint.
#' @field status_code The HTTP response status code.
#' @field status_code_desc The brief description of the HTTP response status code.
#' @field headers The HTTP response headers.
#' @keywords internal
#' @noRd
ApiResponse <- R6::R6Class(
  "ApiResponse",
  public = list(
    content = NULL,
    response = NULL,
    status_code = NULL,
    status_code_desc = NULL,
    headers = NULL,
    
    #' @description
    #' Initialize a new ApiResponse class.
    #'
    #' @param content The deserialized response body.
    #' @param response The raw response from the endpoint.
    #' @param status_code The HTTP response status code.
    #' @param status_code_desc The brief description of the HTTP response status code.
    #' @param headers The HTTP response headers.
    initialize = function(content = NULL,
                          response = NULL,
                          status_code = NULL,
                          status_code_desc = NULL,
                          headers = NULL) {
      self$content <- content
      self$response <- response
      self$status_code <- status_code
      self$status_code_desc <- status_code_desc
      self$headers <- headers
    },
    
    
    #' @description
    #' The response is stored as a raw vector. Use this to access the response after
    #' converting it to text. If the response is not coercible to text NA is returned.
    #'
    #' @param from_encoding The encoding of the raw response.
    #' @param to_encoding The target encoding of the return value.
    response_as_text = function(from_encoding = "", to_encoding = "UTF-8") {
      if (is.null(self$response)) {
        self$response <- charToRaw(jsonlite::toJSON("NULL"))
      }
      text_response <- iconv(readBin(self$response, character()), from = from_encoding, to = to_encoding)
      if (is.na(text_response)) {
        warning("The response is binary and will not be converted to text.")
      }
      return(text_response)
    }
  )
)


#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Auth operations
#' @description AuthApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  ValidateJWT  ####################
#'
#' library(openapi)
#'
#' #Validate JWT
#' api_instance <- AuthApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$ValidateJWT()
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
#' @noRd
AuthApi <- R6::R6Class(
  "AuthApi",
  public = list(
    api_client = NULL,
    
    #' @description
    #' Initialize a new AuthApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    
    #' @description
    #' Validate JWT
    #'
    #' @param ... Other optional arguments
    #'
    #' @return void
    ValidateJWT = function(...) {
      local_var_response <- self$ValidateJWTWithHttpInfo(...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Validate JWT
    #'
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    ValidateJWTWithHttpInfo = function(...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      local_var_url_path <- "/v1/auth/validate"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)


#' Create a new CreateApiKey201Response
#'
#' @description
#' CreateApiKey201Response Class
#'
#' @docType class
#' @title CreateApiKey201Response
#' @description CreateApiKey201Response Class
#' @format An \code{R6Class} generator object
#' @field clientKey The generated API key character [optional]
#' @field clientSecret The generated API secret character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
CreateApiKey201Response <- R6::R6Class(
  "CreateApiKey201Response",
  public = list(
    `clientKey` = NULL,
    `clientSecret` = NULL,
    
    #' @description
    #' Initialize a new CreateApiKey201Response class.
    #'
    #' @param clientKey The generated API key
    #' @param clientSecret The generated API secret
    #' @param ... Other optional arguments.
    initialize = function(`clientKey` = NULL, `clientSecret` = NULL, ...) {
      if (!is.null(`clientKey`)) {
        if (!(is.character(`clientKey`) && length(`clientKey`) == 1)) {
          stop(paste("Error! Invalid data for `clientKey`. Must be a string:", `clientKey`))
        }
        self$`clientKey` <- `clientKey`
      }
      if (!is.null(`clientSecret`)) {
        if (!(is.character(`clientSecret`) && length(`clientSecret`) == 1)) {
          stop(paste("Error! Invalid data for `clientSecret`. Must be a string:", `clientSecret`))
        }
        self$`clientSecret` <- `clientSecret`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return CreateApiKey201Response in JSON format
    toJSON = function() {
      CreateApiKey201ResponseObject <- list()
      if (!is.null(self$`clientKey`)) {
        CreateApiKey201ResponseObject[["clientKey"]] <-
          self$`clientKey`
      }
      if (!is.null(self$`clientSecret`)) {
        CreateApiKey201ResponseObject[["clientSecret"]] <-
          self$`clientSecret`
      }
      CreateApiKey201ResponseObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of CreateApiKey201Response
    #'
    #' @param input_json the JSON input
    #' @return the instance of CreateApiKey201Response
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`clientKey`)) {
        self$`clientKey` <- this_object$`clientKey`
      }
      if (!is.null(this_object$`clientSecret`)) {
        self$`clientSecret` <- this_object$`clientSecret`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return CreateApiKey201Response in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`clientKey`)) {
          sprintf(
            '"clientKey":
            "%s"
                    ',
            self$`clientKey`
          )
        },
        if (!is.null(self$`clientSecret`)) {
          sprintf(
            '"clientSecret":
            "%s"
                    ',
            self$`clientSecret`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of CreateApiKey201Response
    #'
    #' @param input_json the JSON input
    #' @return the instance of CreateApiKey201Response
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`clientKey` <- this_object$`clientKey`
      self$`clientSecret` <- this_object$`clientSecret`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to CreateApiKey201Response and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of CreateApiKey201Response
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# CreateApiKey201Response$unlock()
#
## Below is an example to define the print function
# CreateApiKey201Response$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# CreateApiKey201Response$lock()



#' Create a new Dataset
#'
#' @description
#' Dataset Class
#'
#' @docType class
#' @title Dataset
#' @description Dataset Class
#' @format An \code{R6Class} generator object
#' @field id  integer [optional]
#' @field type  \link{DatasetType}
#' @field entryType  character
#' @field input  list(\link{AnyType})
#' @field result  list(\link{AnyType}) [optional]
#' @field status  character [optional]
#' @field failureReason  character [optional]
#' @field userId  character [optional]
#' @field modelId  integer [optional]
#' @field modelName  character [optional]
#' @field executedAt  character [optional]
#' @field executionFinishedAt  character [optional]
#' @field createdAt  character [optional]
#' @field updatedAt  character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
Dataset <- R6::R6Class(
  "Dataset",
  public = list(
    `id` = NULL,
    `type` = NULL,
    `entryType` = NULL,
    `input` = NULL,
    `result` = NULL,
    `status` = NULL,
    `failureReason` = NULL,
    `userId` = NULL,
    `modelId` = NULL,
    `modelName` = NULL,
    `executedAt` = NULL,
    `executionFinishedAt` = NULL,
    `createdAt` = NULL,
    `updatedAt` = NULL,
    
    #' @description
    #' Initialize a new Dataset class.
    #'
    #' @param type type
    #' @param entryType entryType
    #' @param input input
    #' @param id id
    #' @param result result
    #' @param status status
    #' @param failureReason failureReason
    #' @param userId userId
    #' @param modelId modelId
    #' @param modelName modelName
    #' @param executedAt executedAt
    #' @param executionFinishedAt executionFinishedAt
    #' @param createdAt createdAt
    #' @param updatedAt updatedAt
    #' @param ... Other optional arguments.
    initialize = function(`type`, `entryType`, `input`, `id` = NULL, `result` = NULL, `status` = NULL, `failureReason` = NULL, `userId` = NULL, `modelId` = NULL, `modelName` = NULL, `executedAt` = NULL, `executionFinishedAt` = NULL, `createdAt` = NULL, `updatedAt` = NULL, ...) {
      if (!missing(`type`)) {
        #         if (!(`type` %in% c())) {
        #           stop(paste("Error! \"", `type`, "\" cannot be assigned to `type`. Must be .", sep = ""))
        #         }
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
      if (!missing(`entryType`)) {
        if (!(`entryType` %in% c("ARRAY"))) {
          stop(paste("Error! \"", `entryType`, "\" cannot be assigned to `entryType`. Must be \"ARRAY\".", sep = ""))
        }
        if (!(is.character(`entryType`) && length(`entryType`) == 1)) {
          stop(paste("Error! Invalid data for `entryType`. Must be a string:", `entryType`))
        }
        self$`entryType` <- `entryType`
      }
      if (!missing(`input`)) {
        stopifnot(is.vector(`input`), length(`input`) != 0)
        sapply(`input`, function(x) stopifnot(R6::is.R6(x)))
        self$`input` <- `input`
      }
      if (!is.null(`id`)) {
        if (!(is.numeric(`id`) && length(`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", `id`))
        }
        self$`id` <- `id`
      }
      if (!is.null(`result`)) {
        stopifnot(is.vector(`result`), length(`result`) != 0)
        sapply(`result`, function(x) stopifnot(R6::is.R6(x)))
        self$`result` <- `result`
      }
      if (!is.null(`status`)) {
        if (!(`status` %in% c("CREATED", "EXECUTING", "FAILURE", "SUCCESS"))) {
          stop(paste("Error! \"", `status`, "\" cannot be assigned to `status`. Must be \"CREATED\", \"EXECUTING\", \"FAILURE\", \"SUCCESS\".", sep = ""))
        }
        if (!(is.character(`status`) && length(`status`) == 1)) {
          stop(paste("Error! Invalid data for `status`. Must be a string:", `status`))
        }
        self$`status` <- `status`
      }
      if (!is.null(`failureReason`)) {
        if (!(is.character(`failureReason`) && length(`failureReason`) == 1)) {
          stop(paste("Error! Invalid data for `failureReason`. Must be a string:", `failureReason`))
        }
        self$`failureReason` <- `failureReason`
      }
      if (!is.null(`userId`)) {
        if (!(is.character(`userId`) && length(`userId`) == 1)) {
          stop(paste("Error! Invalid data for `userId`. Must be a string:", `userId`))
        }
        self$`userId` <- `userId`
      }
      if (!is.null(`modelId`)) {
        if (!(is.numeric(`modelId`) && length(`modelId`) == 1)) {
          stop(paste("Error! Invalid data for `modelId`. Must be an integer:", `modelId`))
        }
        self$`modelId` <- `modelId`
      }
      if (!is.null(`modelName`)) {
        if (!(is.character(`modelName`) && length(`modelName`) == 1)) {
          stop(paste("Error! Invalid data for `modelName`. Must be a string:", `modelName`))
        }
        self$`modelName` <- `modelName`
      }
      if (!is.null(`executedAt`)) {
        if (!is.character(`executedAt`)) {
          stop(paste("Error! Invalid data for `executedAt`. Must be a string:", `executedAt`))
        }
        self$`executedAt` <- `executedAt`
      }
      if (!is.null(`executionFinishedAt`)) {
        if (!is.character(`executionFinishedAt`)) {
          stop(paste("Error! Invalid data for `executionFinishedAt`. Must be a string:", `executionFinishedAt`))
        }
        self$`executionFinishedAt` <- `executionFinishedAt`
      }
      if (!is.null(`createdAt`)) {
        if (!is.character(`createdAt`)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", `createdAt`))
        }
        self$`createdAt` <- `createdAt`
      }
      if (!is.null(`updatedAt`)) {
        if (!is.character(`updatedAt`)) {
          stop(paste("Error! Invalid data for `updatedAt`. Must be a string:", `updatedAt`))
        }
        self$`updatedAt` <- `updatedAt`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Dataset in JSON format
    toJSON = function() {
      DatasetObject <- list()
      if (!is.null(self$`id`)) {
        DatasetObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`type`)) {
        DatasetObject[["type"]] <-
          self$`type`$toJSON()
      }
      if (!is.null(self$`entryType`)) {
        DatasetObject[["entryType"]] <-
          self$`entryType`
      }
      if (!is.null(self$`input`)) {
        DatasetObject[["input"]] <-
          lapply(self$`input`, function(x) x$data)
      }
      if (!is.null(self$`result`)) {
        DatasetObject[["result"]] <-
          lapply(self$`result`, function(x) x$toJSON())
      }
      if (!is.null(self$`status`)) {
        DatasetObject[["status"]] <-
          self$`status`
      }
      if (!is.null(self$`failureReason`)) {
        DatasetObject[["failureReason"]] <-
          self$`failureReason`
      }
      if (!is.null(self$`userId`)) {
        DatasetObject[["userId"]] <-
          self$`userId`
      }
      if (!is.null(self$`modelId`)) {
        DatasetObject[["modelId"]] <-
          self$`modelId`
      }
      if (!is.null(self$`modelName`)) {
        DatasetObject[["modelName"]] <-
          self$`modelName`
      }
      if (!is.null(self$`executedAt`)) {
        DatasetObject[["executedAt"]] <-
          self$`executedAt`
      }
      if (!is.null(self$`executionFinishedAt`)) {
        DatasetObject[["executionFinishedAt"]] <-
          self$`executionFinishedAt`
      }
      if (!is.null(self$`createdAt`)) {
        DatasetObject[["createdAt"]] <-
          self$`createdAt`
      }
      if (!is.null(self$`updatedAt`)) {
        DatasetObject[["updatedAt"]] <-
          self$`updatedAt`
      }
      DatasetObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Dataset
    #'
    #' @param input_json the JSON input
    #' @return the instance of Dataset
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`type`)) {
        `type_object` <- DatasetType$new()
        `type_object`$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
        self$`type` <- `type_object`
      }
      if (!is.null(this_object$`entryType`)) {
        if (!is.null(this_object$`entryType`) && !(this_object$`entryType` %in% c("ARRAY"))) {
          stop(paste("Error! \"", this_object$`entryType`, "\" cannot be assigned to `entryType`. Must be \"ARRAY\".", sep = ""))
        }
        self$`entryType` <- this_object$`entryType`
      }
      if (!is.null(this_object$`input`)) {
        self$`input` <- ApiClient$new()$deserializeObj(this_object$`input`, "array[AnyType]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`result`)) {
        self$`result` <- ApiClient$new()$deserializeObj(this_object$`result`, "array[AnyType]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`status`)) {
        if (!is.null(this_object$`status`) && !(this_object$`status` %in% c("CREATED", "EXECUTING", "FAILURE", "SUCCESS"))) {
          stop(paste("Error! \"", this_object$`status`, "\" cannot be assigned to `status`. Must be \"CREATED\", \"EXECUTING\", \"FAILURE\", \"SUCCESS\".", sep = ""))
        }
        self$`status` <- this_object$`status`
      }
      if (!is.null(this_object$`failureReason`)) {
        self$`failureReason` <- this_object$`failureReason`
      }
      if (!is.null(this_object$`userId`)) {
        self$`userId` <- this_object$`userId`
      }
      if (!is.null(this_object$`modelId`)) {
        self$`modelId` <- this_object$`modelId`
      }
      if (!is.null(this_object$`modelName`)) {
        self$`modelName` <- this_object$`modelName`
      }
      if (!is.null(this_object$`executedAt`)) {
        self$`executedAt` <- this_object$`executedAt`
      }
      if (!is.null(this_object$`executionFinishedAt`)) {
        self$`executionFinishedAt` <- this_object$`executionFinishedAt`
      }
      if (!is.null(this_object$`createdAt`)) {
        self$`createdAt` <- this_object$`createdAt`
      }
      if (!is.null(this_object$`updatedAt`)) {
        self$`updatedAt` <- this_object$`updatedAt`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Dataset in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                    ',
            self$`id`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
            '"type":
          %s
          ',
            self$`type`$toJSON()
          )
        },
        if (!is.null(self$`entryType`)) {
          sprintf(
            '"entryType":
            "%s"
                    ',
            self$`entryType`
          )
        },
        if (!is.null(self$`input`)) {
          sprintf(
            '"input":
          [%s]
',
            paste(sapply(self$`input`, function(x) jsonlite::toJSON(x$data, auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`result`)) {
          sprintf(
            '"result":
          [%s]
',
            paste(sapply(self$`result`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`status`)) {
          sprintf(
            '"status":
            "%s"
                    ',
            self$`status`
          )
        },
        if (!is.null(self$`failureReason`)) {
          sprintf(
            '"failureReason":
            "%s"
                    ',
            self$`failureReason`
          )
        },
        if (!is.null(self$`userId`)) {
          sprintf(
            '"userId":
            "%s"
                    ',
            self$`userId`
          )
        },
        if (!is.null(self$`modelId`)) {
          sprintf(
            '"modelId":
            %d
                    ',
            self$`modelId`
          )
        },
        if (!is.null(self$`modelName`)) {
          sprintf(
            '"modelName":
            "%s"
                    ',
            self$`modelName`
          )
        },
        if (!is.null(self$`executedAt`)) {
          sprintf(
            '"executedAt":
            "%s"
                    ',
            self$`executedAt`
          )
        },
        if (!is.null(self$`executionFinishedAt`)) {
          sprintf(
            '"executionFinishedAt":
            "%s"
                    ',
            self$`executionFinishedAt`
          )
        },
        if (!is.null(self$`createdAt`)) {
          sprintf(
            '"createdAt":
            "%s"
                    ',
            self$`createdAt`
          )
        },
        if (!is.null(self$`updatedAt`)) {
          sprintf(
            '"updatedAt":
            "%s"
                    ',
            self$`updatedAt`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Dataset
    #'
    #' @param input_json the JSON input
    #' @return the instance of Dataset
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`type` <- DatasetType$new()$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
      if (!is.null(this_object$`entryType`) && !(this_object$`entryType` %in% c("ARRAY"))) {
        stop(paste("Error! \"", this_object$`entryType`, "\" cannot be assigned to `entryType`. Must be \"ARRAY\".", sep = ""))
      }
      self$`entryType` <- this_object$`entryType`
      self$`input` <- ApiClient$new()$deserializeObj(this_object$`input`, "array[AnyType]", loadNamespace("openapi"))
      self$`result` <- ApiClient$new()$deserializeObj(this_object$`result`, "array[AnyType]", loadNamespace("openapi"))
      if (!is.null(this_object$`status`) && !(this_object$`status` %in% c("CREATED", "EXECUTING", "FAILURE", "SUCCESS"))) {
        stop(paste("Error! \"", this_object$`status`, "\" cannot be assigned to `status`. Must be \"CREATED\", \"EXECUTING\", \"FAILURE\", \"SUCCESS\".", sep = ""))
      }
      self$`status` <- this_object$`status`
      self$`failureReason` <- this_object$`failureReason`
      self$`userId` <- this_object$`userId`
      self$`modelId` <- this_object$`modelId`
      self$`modelName` <- this_object$`modelName`
      self$`executedAt` <- this_object$`executedAt`
      self$`executionFinishedAt` <- this_object$`executionFinishedAt`
      self$`createdAt` <- this_object$`createdAt`
      self$`updatedAt` <- this_object$`updatedAt`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to Dataset and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `type`
      if (!is.null(input_json$`type`)) {
        stopifnot(R6::is.R6(input_json$`type`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Dataset: the required field `type` is missing."))
      }
      # check the required field `entryType`
      if (!is.null(input_json$`entryType`)) {
        if (!(is.character(input_json$`entryType`) && length(input_json$`entryType`) == 1)) {
          stop(paste("Error! Invalid data for `entryType`. Must be a string:", input_json$`entryType`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Dataset: the required field `entryType` is missing."))
      }
      # check the required field `input`
      if (!is.null(input_json$`input`)) {
        stopifnot(is.vector(input_json$`input`), length(input_json$`input`) != 0)
        tmp <- sapply(input_json$`input`, function(x) stopifnot(R6::is.R6(x)))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Dataset: the required field `input` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Dataset
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        return(FALSE)
      }
      
      # check if the required `entryType` is null
      if (is.null(self$`entryType`)) {
        return(FALSE)
      }
      
      # check if the required `input` is null
      if (is.null(self$`input`)) {
        return(FALSE)
      }
      
      if (length(self$`input`) > 100) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        invalid_fields["type"] <- "Non-nullable required field `type` cannot be null."
      }
      
      # check if the required `entryType` is null
      if (is.null(self$`entryType`)) {
        invalid_fields["entryType"] <- "Non-nullable required field `entryType` cannot be null."
      }
      
      # check if the required `input` is null
      if (is.null(self$`input`)) {
        invalid_fields["input"] <- "Non-nullable required field `input` cannot be null."
      }
      
      if (length(self$`input`) > 100) {
        invalid_fields["input"] <- "Invalid length for `input`, number of items must be less than or equal to 100."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# Dataset$unlock()
#
## Below is an example to define the print function
# Dataset$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# Dataset$lock()


#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Dataset operations
#' @description DatasetApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  GetDatasetById  ####################
#'
#' library(openapi)
#' var_id <- 0 # integer | The ID of the dataset to retrieve
#'
#' #Get a Dataset
#' api_instance <- DatasetApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetDatasetById(var_iddata_file = "result.txt")
#' result <- api_instance$GetDatasetById(var_id)
#' dput(result)
#'
#'
#' ####################  GetDatasets  ####################
#'
#' library(openapi)
#' var_page <- 0 # integer |  (Optional)
#' var_size <- 10 # integer |  (Optional)
#' var_sort <- c("inner_example") # array[character] |  (Optional)
#'
#' #Get Datasets by User ID
#' api_instance <- DatasetApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetDatasets(page = var_page, size = var_size, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$GetDatasets(page = var_page, size = var_size, sort = var_sort)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
#' @noRd
DatasetApi <- R6::R6Class(
  "DatasetApi",
  public = list(
    api_client = NULL,
    
    #' @description
    #' Initialize a new DatasetApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    
    #' @description
    #' Get a Dataset
    #'
    #' @param id The ID of the dataset to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return Dataset
    GetDatasetById = function(id, data_file = NULL, ...) {
      local_var_response <- self$GetDatasetByIdWithHttpInfo(id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },
    
    #' @description
    #' Get a Dataset
    #'
    #' @param id The ID of the dataset to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (Dataset) with additional information such as HTTP status code, headers
    GetDatasetByIdWithHttpInfo = function(id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }
      
      
      local_var_url_path <- "/v1/datasets/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        # deserialized_resp_obj <- tryCatch(
        #   self$api_client$deserialize(local_var_resp$response_as_text(), "Dataset", loadNamespace("openapi")),
        #   error = function(e) {
        #     stop("Failed to deserialize response")
        #   }
        # )
        local_var_resp$content <- jsonlite::fromJSON(local_var_resp$response_as_text())
        return(local_var_resp)
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
        print(paste0("Error, status code ", local_var_resp$status_code))
        return(local_var_resp)
        
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
        print(paste0("API client error, status code ", local_var_resp$status_code))
        return(local_var_resp)
        
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        print(paste0("API server error, status code ", local_var_resp$status_code))
        return(local_var_resp)
      }
    },
    
    #' @description
    #' Get Datasets by User ID
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return GetDatasets200Response
    GetDatasets = function(page = 0, size = 10, sort = NULL, data_file = NULL, ...) {
      local_var_response <- self$GetDatasetsWithHttpInfo(page, size, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get Datasets by User ID
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (GetDatasets200Response) with additional information such as HTTP status code, headers
    GetDatasetsWithHttpInfo = function(page = 0, size = 10, sort = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      
      
      
      query_params[["page"]] <- `page`
      
      query_params[["size"]] <- `size`
      
      # explore
      for (query_item in `sort`) {
        query_params[["sort"]] <- c(query_params[["sort"]], list(`sort` = query_item))
      }
      
      local_var_url_path <- "/v1/user/datasets"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "GetDatasets200Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)


#' @docType class
#' @title DatasetType
#' @description DatasetType Class
#' @format An \code{R6Class} generator object
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
DatasetType <- R6::R6Class(
  "DatasetType",
  public = list(
    
    #' @description
    #' Initialize a new DatasetType class.
    #'
    #' @param ... Optional arguments.
    initialize = function(...) {
      local.optional.var <- list(...)
      val <- unlist(local.optional.var)
      enumvec <- .parse_DatasetType()
      
      if (length(val) == 0L) {
        val = "DUMMY_ENUM"
      } else {
        stopifnot(length(val) == 1L)
      }
      
      if (!val %in% enumvec) {
        if (!(val=="DUMMY_ENUM")) {
          stop("Use one of the valid values: ",
               paste0(enumvec, collapse = ", "))
        }
        warning("Initializing DatasetType with DUMMY_ENUM. Use one of the valid values: ",
                paste0(enumvec, collapse = ", "),
                ". If you did not manually initialize DatasetType, this may already be overwritten by an enum loaded from a JSON config.")
      }
      private$value <- val
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return DatasetType in JSON format
    toJSON = function() {
      jsonlite::toJSON(private$value, auto_unbox = TRUE)
    },
    
    #' @description
    #' Deserialize JSON string into an instance of DatasetType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of DatasetType
    fromJSON = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return DatasetType in JSON format
    toJSONString = function() {
      jsonlite::toJSON(private$value,
                       auto_unbox = TRUE)
    },
    
    #' @description
    #' Deserialize JSON string into an instance of DatasetType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of DatasetType
    fromJSONString = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = TRUE)
      self
    }
  ),
  private = list(
    value = NULL
  )
)

# # add to utils.R
# .parse_DatasetType <- function(vals) {
#   res <- gsub("^\\[|\\]$", "", "[PREDICTION]")
#   unlist(strsplit(res, ", "))
# }

# Enum definition
.parse_DatasetType <- function() {
  c("PREDICTION", "DUMMY_ENUM")
}


#' Create a new Feature
#'
#' @description
#' Feature Class
#'
#' @docType class
#' @title Feature
#' @description Feature Class
#' @format An \code{R6Class} generator object
#' @field id  integer [optional]
#' @field key A key that must start with a letter, followed by any combination of letters, digits, hyphens, or underscores. For example, 'abc123', 'abc-test', or 'Abc_test'. It cannot start with a digit. character
#' @field name A name for the feature that will appear on top of the form field character
#' @field units The units for the feature character [optional]
#' @field range The range for the feature character [optional]
#' @field description  character [optional]
#' @field featureType  \link{FeatureType}
#' @field featureDependency  character [optional]
#' @field visible  character [optional]
#' @field possibleValues  list(\link{FeaturePossibleValue}) [optional]
#' @field createdAt The date and time when the feature was created. character [optional]
#' @field updatedAt The date and time when the feature was last updated. character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
Feature <- R6::R6Class(
  "Feature",
  public = list(
    `id` = NULL,
    `key` = NULL,
    `name` = NULL,
    `units` = NULL,
    `range` = NULL,
    `description` = NULL,
    `featureType` = NULL,
    `featureDependency` = NULL,
    `visible` = NULL,
    `possibleValues` = NULL,
    `createdAt` = NULL,
    `updatedAt` = NULL,
    
    #' @description
    #' Initialize a new Feature class.
    #'
    #' @param key A key that must start with a letter, followed by any combination of letters, digits, hyphens, or underscores. For example, 'abc123', 'abc-test', or 'Abc_test'. It cannot start with a digit.
    #' @param name A name for the feature that will appear on top of the form field
    #' @param featureType featureType
    #' @param id id
    #' @param units The units for the feature
    #' @param range The range for the feature
    #' @param description description
    #' @param featureDependency featureDependency
    #' @param visible visible
    #' @param possibleValues possibleValues
    #' @param createdAt The date and time when the feature was created.
    #' @param updatedAt The date and time when the feature was last updated.
    #' @param ... Other optional arguments.
    initialize = function(`key`, `name`, `featureType`, `id` = NULL, `units` = NULL, `range` = NULL, `description` = NULL, `featureDependency` = NULL, `visible` = NULL, `possibleValues` = NULL, `createdAt` = NULL, `updatedAt` = NULL, ...) {
      if (!missing(`key`)) {
        if (!(is.character(`key`) && length(`key`) == 1)) {
          stop(paste("Error! Invalid data for `key`. Must be a string:", `key`))
        }
        self$`key` <- `key`
      }
      if (!missing(`name`)) {
        if (!(is.character(`name`) && length(`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", `name`))
        }
        self$`name` <- `name`
      }
      if (!missing(`featureType`)) {
        if (!(as.character(`featureType`$toJSON()) %in% c("\"INTEGER\"", "\"FLOAT\"", "\"CATEGORICAL\"", 
                                                          "\"SMILES\"", "\"STRING\"", "\"TEXT\"", "\"FLOAT_ARRAY\"",
                                                          "\"STRING_ARRAY\""))) {
          stop(paste("Error! \"", `featureType`, "\" cannot be assigned to `featureType`. Must be .", sep = ""))
          
        }
        stopifnot(R6::is.R6(`featureType`))
        self$`featureType` <- `featureType`
      }
      
      if (!is.null(`id`)) {
        if (!(is.numeric(`id`) && length(`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", `id`))
        }
        self$`id` <- `id`
      }
      if (!is.null(`units`)) {
        if (!(is.character(`units`) && length(`units`) == 1)) {
          stop(paste("Error! Invalid data for `units`. Must be a string:", `units`))
        }
        self$`units` <- `units`
      }
      if (!is.null(`range`)) {
        if (!(is.character(`range`) && length(`range`) == 1)) {
          stop(paste("Error! Invalid data for `range`. Must be a string:", `range`))
        }
        self$`range` <- `range`
      }
      if (!is.null(`description`)) {
        if (!(is.character(`description`) && length(`description`) == 1)) {
          stop(paste("Error! Invalid data for `description`. Must be a string:", `description`))
        }
        self$`description` <- `description`
      }
      if (!is.null(`featureDependency`)) {
        #         if (!(`featureDependency` %in% c("DEPENDENT", "INDEPENDENT"))) {
        #           stop(paste("Error! \"", `featureDependency`, "\" cannot be assigned to `featureDependency`. Must be \"DEPENDENT\", \"INDEPENDENT\".", sep = ""))
        #         }
        if (!(is.character(`featureDependency`) && length(`featureDependency`) == 1)) {
          stop(paste("Error! Invalid data for `featureDependency`. Must be a string:", `featureDependency`))
        }
        self$`featureDependency` <- `featureDependency`
      }
      if (!is.null(`visible`)) {
        if (!(is.logical(`visible`) && length(`visible`) == 1)) {
          stop(paste("Error! Invalid data for `visible`. Must be a boolean:", `visible`))
        }
        self$`visible` <- `visible`
      }
      if (!is.null(`possibleValues`)) {
        stopifnot(is.vector(`possibleValues`), length(`possibleValues`) != 0)
        sapply(`possibleValues`, function(x) stopifnot(R6::is.R6(x)))
        self$`possibleValues` <- `possibleValues`
      }
      if (!is.null(`createdAt`)) {
        if (!is.character(`createdAt`)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", `createdAt`))
        }
        self$`createdAt` <- `createdAt`
      }
      if (!is.null(`updatedAt`)) {
        if (!is.character(`updatedAt`)) {
          stop(paste("Error! Invalid data for `updatedAt`. Must be a string:", `updatedAt`))
        }
        self$`updatedAt` <- `updatedAt`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Feature in JSON format
    toJSON = function() {
      FeatureObject <- list()
      if (!is.null(self$`id`)) {
        FeatureObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`key`)) {
        FeatureObject[["key"]] <-
          self$`key`
      }
      if (!is.null(self$`name`)) {
        FeatureObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`units`)) {
        FeatureObject[["units"]] <-
          self$`units`
      }
      if (!is.null(self$`range`)) {
        FeatureObject[["range"]] <-
          self$`range`
      }
      if (!is.null(self$`description`)) {
        FeatureObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`featureType`)) {
        FeatureObject[["featureType"]] <-
          self$`featureType`$getValue()
      }
      if (!is.null(self$`featureDependency`)) {
        FeatureObject[["featureDependency"]] <-
          self$`featureDependency`
      }
      if (!is.null(self$`visible`)) {
        FeatureObject[["visible"]] <-
          self$`visible`
      }
      if (!is.null(self$`possibleValues`)) {
        FeatureObject[["possibleValues"]] <-
          lapply(self$`possibleValues`, function(x) x$toJSON())
      }
      if (!is.null(self$`createdAt`)) {
        FeatureObject[["createdAt"]] <-
          self$`createdAt`
      }
      if (!is.null(self$`updatedAt`)) {
        FeatureObject[["updatedAt"]] <-
          self$`updatedAt`
      }
      FeatureObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Feature
    #'
    #' @param input_json the JSON input
    #' @return the instance of Feature
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`key`)) {
        self$`key` <- this_object$`key`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`units`)) {
        self$`units` <- this_object$`units`
      }
      if (!is.null(this_object$`range`)) {
        self$`range` <- this_object$`range`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`featureType`)) {
        `featuretype_object` <- FeatureType$new()
        `featuretype_object`$fromJSON(jsonlite::toJSON(this_object$`featureType`, auto_unbox = TRUE, digits = NA))
        self$`featureType` <- `featuretype_object`
      }
      if (!is.null(this_object$`featureDependency`)) {
        if (!is.null(this_object$`featureDependency`) && !(this_object$`featureDependency` %in% c("DEPENDENT", "INDEPENDENT"))) {
          stop(paste("Error! \"", this_object$`featureDependency`, "\" cannot be assigned to `featureDependency`. Must be \"DEPENDENT\", \"INDEPENDENT\".", sep = ""))
        }
        self$`featureDependency` <- this_object$`featureDependency`
      }
      if (!is.null(this_object$`visible`)) {
        self$`visible` <- this_object$`visible`
      }
      if (!is.null(this_object$`possibleValues`)) {
        self$`possibleValues` <- ApiClient$new()$deserializeObj(this_object$`possibleValues`, "array[FeaturePossibleValue]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`createdAt`)) {
        self$`createdAt` <- this_object$`createdAt`
      }
      if (!is.null(this_object$`updatedAt`)) {
        self$`updatedAt` <- this_object$`updatedAt`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Feature in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                    ',
            self$`id`
          )
        },
        if (!is.null(self$`key`)) {
          sprintf(
            '"key":
            "%s"
                    ',
            self$`key`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                    ',
            self$`name`
          )
        },
        if (!is.null(self$`units`)) {
          sprintf(
            '"units":
            "%s"
                    ',
            self$`units`
          )
        },
        if (!is.null(self$`range`)) {
          sprintf(
            '"range":
            "%s"
                    ',
            self$`range`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
            '"description":
            "%s"
                    ',
            self$`description`
          )
        },
        if (!is.null(self$`featureType`)) {
          sprintf(
            '"featureType":
          %s
          ',
            jsonlite::toJSON(self$`featureType`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`featureDependency`)) {
          sprintf(
            '"featureDependency":
            "%s"
                    ',
            self$`featureDependency`
          )
        },
        if (!is.null(self$`visible`)) {
          sprintf(
            '"visible":
            %s
                    ',
            tolower(self$`visible`)
          )
        },
        if (!is.null(self$`possibleValues`)) {
          sprintf(
            '"possibleValues":
          [%s]
',
            paste(sapply(self$`possibleValues`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`createdAt`)) {
          sprintf(
            '"createdAt":
            "%s"
                    ',
            self$`createdAt`
          )
        },
        if (!is.null(self$`updatedAt`)) {
          sprintf(
            '"updatedAt":
            "%s"
                    ',
            self$`updatedAt`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Feature
    #'
    #' @param input_json the JSON input
    #' @return the instance of Feature
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`key` <- this_object$`key`
      self$`name` <- this_object$`name`
      self$`units` <- this_object$`units`
      self$`range` <- this_object$`range`
      self$`description` <- this_object$`description`
      self$`featureType` <- FeatureType$new()$fromJSON(jsonlite::toJSON(this_object$`featureType`, auto_unbox = TRUE, digits = NA))
      if (!is.null(this_object$`featureDependency`) && !(this_object$`featureDependency` %in% c("DEPENDENT", "INDEPENDENT"))) {
        stop(paste("Error! \"", this_object$`featureDependency`, "\" cannot be assigned to `featureDependency`. Must be \"DEPENDENT\", \"INDEPENDENT\".", sep = ""))
      }
      self$`featureDependency` <- this_object$`featureDependency`
      self$`visible` <- this_object$`visible`
      self$`possibleValues` <- ApiClient$new()$deserializeObj(this_object$`possibleValues`, "array[FeaturePossibleValue]", loadNamespace("openapi"))
      self$`createdAt` <- this_object$`createdAt`
      self$`updatedAt` <- this_object$`updatedAt`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to Feature and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `key`
      if (!is.null(input_json$`key`)) {
        if (!(is.character(input_json$`key`) && length(input_json$`key`) == 1)) {
          stop(paste("Error! Invalid data for `key`. Must be a string:", input_json$`key`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Feature: the required field `key` is missing."))
      }
      # check the required field `name`
      if (!is.null(input_json$`name`)) {
        if (!(is.character(input_json$`name`) && length(input_json$`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", input_json$`name`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Feature: the required field `name` is missing."))
      }
      # check the required field `featureType`
      if (!is.null(input_json$`featureType`)) {
        stopifnot(R6::is.R6(input_json$`featureType`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Feature: the required field `featureType` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Feature
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `key` is null
      if (is.null(self$`key`)) {
        return(FALSE)
      }
      
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        return(FALSE)
      }
      
      if (nchar(self$`name`) > 255) {
        return(FALSE)
      }
      
      if (nchar(self$`units`) > 255) {
        return(FALSE)
      }
      
      if (nchar(self$`range`) > 255) {
        return(FALSE)
      }
      
      if (nchar(self$`description`) > 2000) {
        return(FALSE)
      }
      
      # check if the required `featureType` is null
      if (is.null(self$`featureType`)) {
        return(FALSE)
      }
      
      if (length(self$`possibleValues`) > 1000) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `key` is null
      if (is.null(self$`key`)) {
        invalid_fields["key"] <- "Non-nullable required field `key` cannot be null."
      }
      
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        invalid_fields["name"] <- "Non-nullable required field `name` cannot be null."
      }
      
      if (nchar(self$`name`) > 255) {
        invalid_fields["name"] <- "Invalid length for `name`, must be smaller than or equal to 255."
      }
      
      if (nchar(self$`units`) > 255) {
        invalid_fields["units"] <- "Invalid length for `units`, must be smaller than or equal to 255."
      }
      
      if (nchar(self$`range`) > 255) {
        invalid_fields["range"] <- "Invalid length for `range`, must be smaller than or equal to 255."
      }
      
      if (nchar(self$`description`) > 2000) {
        invalid_fields["description"] <- "Invalid length for `description`, must be smaller than or equal to 2000."
      }
      
      # check if the required `featureType` is null
      if (is.null(self$`featureType`)) {
        invalid_fields["featureType"] <- "Non-nullable required field `featureType` cannot be null."
      }
      
      if (length(self$`possibleValues`) > 1000) {
        invalid_fields["possibleValues"] <- "Invalid length for `possibleValues`, number of items must be less than or equal to 1000."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# Feature$unlock()
#
## Below is an example to define the print function
# Feature$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# Feature$lock()


#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Feature operations
#' @description FeatureApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  PartiallyUpdateModelFeature  ####################
#'
#' library(openapi)
#' var_model_id <- 56 # integer | The ID of the model containing the feature
#' var_feature_id <- 56 # integer | The ID of the feature to update
#' var_partially_update_model_feature_request <- partiallyUpdateModelFeature_request$new("name_example", FeatureType$new(), "units_example", "range_example", "description_example", c(FeaturePossibleValue$new("key_example", "value_example"))) # PartiallyUpdateModelFeatureRequest | 
#'
#' #Update a feature for a specific model
#' api_instance <- FeatureApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$PartiallyUpdateModelFeature(var_model_id, var_feature_id, var_partially_update_model_feature_requestdata_file = "result.txt")
#' result <- api_instance$PartiallyUpdateModelFeature(var_model_id, var_feature_id, var_partially_update_model_feature_request)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
#' @noRd
FeatureApi <- R6::R6Class(
  "FeatureApi",
  public = list(
    api_client = NULL,
    
    #' @description
    #' Initialize a new FeatureApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    
    #' @description
    #' Update a feature for a specific model
    #'
    #' @param model_id The ID of the model containing the feature
    #' @param feature_id The ID of the feature to update
    #' @param partially_update_model_feature_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return Feature
    PartiallyUpdateModelFeature = function(model_id, feature_id, partially_update_model_feature_request, data_file = NULL, ...) {
      local_var_response <- self$PartiallyUpdateModelFeatureWithHttpInfo(model_id, feature_id, partially_update_model_feature_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Update a feature for a specific model
    #'
    #' @param model_id The ID of the model containing the feature
    #' @param feature_id The ID of the feature to update
    #' @param partially_update_model_feature_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (Feature) with additional information such as HTTP status code, headers
    PartiallyUpdateModelFeatureWithHttpInfo = function(model_id, feature_id, partially_update_model_feature_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`model_id`)) {
        stop("Missing required parameter `model_id`.")
      }
      
      if (missing(`feature_id`)) {
        stop("Missing required parameter `feature_id`.")
      }
      
      if (missing(`partially_update_model_feature_request`)) {
        stop("Missing required parameter `partially_update_model_feature_request`.")
      }
      
      
      
      
      if (!is.null(`partially_update_model_feature_request`)) {
        local_var_body <- `partially_update_model_feature_request`$toJSONString()
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/models/{modelId}/features/{featureId}"
      if (!missing(`model_id`)) {
        local_var_url_path <- gsub("\\{modelId\\}", URLencode(as.character(`model_id`), reserved = TRUE), local_var_url_path)
      }
      
      if (!missing(`feature_id`)) {
        local_var_url_path <- gsub("\\{featureId\\}", URLencode(as.character(`feature_id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "PATCH",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "Feature", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)


#' Create a new FeaturePossibleValue
#'
#' @description
#' FeaturePossibleValue Class
#'
#' @docType class
#' @title FeaturePossibleValue
#' @description FeaturePossibleValue Class
#' @format An \code{R6Class} generator object
#' @field key  character
#' @field value  character
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
FeaturePossibleValue <- R6::R6Class(
  "FeaturePossibleValue",
  public = list(
    `key` = NULL,
    `value` = NULL,
    
    #' @description
    #' Initialize a new FeaturePossibleValue class.
    #'
    #' @param key key
    #' @param value value
    #' @param ... Other optional arguments.
    initialize = function(`key`, `value`, ...) {
      if (!missing(`key`)) {
        if (!(is.character(`key`) && length(`key`) == 1)) {
          stop(paste("Error! Invalid data for `key`. Must be a string:", `key`))
        }
        self$`key` <- `key`
      }
      if (!missing(`value`)) {
        if (!(is.character(`value`) && length(`value`) == 1)) {
          stop(paste("Error! Invalid data for `value`. Must be a string:", `value`))
        }
        self$`value` <- `value`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return FeaturePossibleValue in JSON format
    toJSON = function() {
      FeaturePossibleValueObject <- list()
      if (!is.null(self$`key`)) {
        FeaturePossibleValueObject[["key"]] <-
          self$`key`
      }
      if (!is.null(self$`value`)) {
        FeaturePossibleValueObject[["value"]] <-
          self$`value`
      }
      FeaturePossibleValueObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of FeaturePossibleValue
    #'
    #' @param input_json the JSON input
    #' @return the instance of FeaturePossibleValue
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`key`)) {
        self$`key` <- this_object$`key`
      }
      if (!is.null(this_object$`value`)) {
        self$`value` <- this_object$`value`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return FeaturePossibleValue in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`key`)) {
          sprintf(
            '"key":
            "%s"
                    ',
            self$`key`
          )
        },
        if (!is.null(self$`value`)) {
          sprintf(
            '"value":
            "%s"
                    ',
            self$`value`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of FeaturePossibleValue
    #'
    #' @param input_json the JSON input
    #' @return the instance of FeaturePossibleValue
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`key` <- this_object$`key`
      self$`value` <- this_object$`value`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to FeaturePossibleValue and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `key`
      if (!is.null(input_json$`key`)) {
        if (!(is.character(input_json$`key`) && length(input_json$`key`) == 1)) {
          stop(paste("Error! Invalid data for `key`. Must be a string:", input_json$`key`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for FeaturePossibleValue: the required field `key` is missing."))
      }
      # check the required field `value`
      if (!is.null(input_json$`value`)) {
        if (!(is.character(input_json$`value`) && length(input_json$`value`) == 1)) {
          stop(paste("Error! Invalid data for `value`. Must be a string:", input_json$`value`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for FeaturePossibleValue: the required field `value` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of FeaturePossibleValue
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `key` is null
      if (is.null(self$`key`)) {
        return(FALSE)
      }
      
      # check if the required `value` is null
      if (is.null(self$`value`)) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `key` is null
      if (is.null(self$`key`)) {
        invalid_fields["key"] <- "Non-nullable required field `key` cannot be null."
      }
      
      # check if the required `value` is null
      if (is.null(self$`value`)) {
        invalid_fields["value"] <- "Non-nullable required field `value` cannot be null."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# FeaturePossibleValue$unlock()
#
## Below is an example to define the print function
# FeaturePossibleValue$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# FeaturePossibleValue$lock()


#' @docType class
#' @title FeatureType
#' @description FeatureType Class
#' @format An \code{R6Class} generator object
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
FeatureType <- R6::R6Class(
  "FeatureType",
  public = list(
    
    #' @description
    #' Initialize a new FeatureType class.
    #'
    #' @param ... Optional arguments.
    initialize = function(...) {
      local.optional.var <- list(...)
      val <- unlist(local.optional.var)
      enumvec <- .parse_FeatureType()
      
      if (length(val) == 0L) {
        val = "DUMMY_ENUM"
      } else {
        stopifnot(length(val) == 1L)
      }
      
      if (!val %in% enumvec) {
        if (!(val=="DUMMY_ENUM")) {
          stop("Use one of the valid values: ",
               paste0(enumvec, collapse = ", "))
        }
        warning("Initializing FeatureType with DUMMY_ENUM. Use one of the valid values: ",
                paste0(enumvec, collapse = ", "),
                ". If you did not manually initialize FeatureType, this may already be overwritten by an enum loaded from a JSON config.")
      }
      
      private$value <- val
      
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return FeatureType in JSON format
    toJSON = function() {
      jsonlite::toJSON(private$value, auto_unbox = TRUE)
    },
    
    #' @description
    #' Get string value
    #'
    #' @return string
    getValue = function() {
      private$value
    },
    
    #' @description
    #' Deserialize JSON string into an instance of FeatureType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of FeatureType
    fromJSON = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return FeatureType in JSON format
    toJSONString = function() {
      as.character(jsonlite::toJSON(private$value,
                                    auto_unbox = TRUE))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of FeatureType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of FeatureType
    fromJSONString = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    }
  ),
  private = list(
    value = NULL
  )
)

# add to utils.R
.parse_FeatureType <- function(vals) {
  res <- gsub("^\\[|\\]$", "", "[INTEGER, FLOAT, CATEGORICAL, SMILES, STRING, TEXT, FLOAT_ARRAY, STRING_ARRAY]")
  unlist(strsplit(res, ", "))
}


#' Create a new Library
#'
#' @description
#' Library Class
#'
#' @docType class
#' @title Library
#' @description Library Class
#' @format An \code{R6Class} generator object
#' @field id  integer [optional]
#' @field name  character
#' @field version  character
#' @field createdAt The date and time when the feature was created. character [optional]
#' @field updatedAt The date and time when the feature was last updated. character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
Library <- R6::R6Class(
  "Library",
  public = list(
    `id` = NULL,
    `name` = NULL,
    `version` = NULL,
    `createdAt` = NULL,
    `updatedAt` = NULL,
    
    #' @description
    #' Initialize a new Library class.
    #'
    #' @param name name
    #' @param version version
    #' @param id id
    #' @param createdAt The date and time when the feature was created.
    #' @param updatedAt The date and time when the feature was last updated.
    #' @param ... Other optional arguments.
    initialize = function(`name`, `version`, `id` = NULL, `createdAt` = NULL, `updatedAt` = NULL, ...) {
      if (!missing(`name`)) {
        if (!(is.character(`name`) && length(`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", `name`))
        }
        self$`name` <- `name`
      }
      if (!missing(`version`)) {
        if (!(is.character(`version`) && length(`version`) == 1)) {
          stop(paste("Error! Invalid data for `version`. Must be a string:", `version`))
        }
        self$`version` <- `version`
      }
      if (!is.null(`id`)) {
        if (!(is.numeric(`id`) && length(`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", `id`))
        }
        self$`id` <- `id`
      }
      if (!is.null(`createdAt`)) {
        if (!is.character(`createdAt`)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", `createdAt`))
        }
        self$`createdAt` <- `createdAt`
      }
      if (!is.null(`updatedAt`)) {
        if (!is.character(`updatedAt`)) {
          stop(paste("Error! Invalid data for `updatedAt`. Must be a string:", `updatedAt`))
        }
        self$`updatedAt` <- `updatedAt`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Library in JSON format
    toJSON = function() {
      LibraryObject <- list()
      if (!is.null(self$`id`)) {
        LibraryObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`name`)) {
        LibraryObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`version`)) {
        LibraryObject[["version"]] <-
          self$`version`
      }
      if (!is.null(self$`createdAt`)) {
        LibraryObject[["createdAt"]] <-
          self$`createdAt`
      }
      if (!is.null(self$`updatedAt`)) {
        LibraryObject[["updatedAt"]] <-
          self$`updatedAt`
      }
      LibraryObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Library
    #'
    #' @param input_json the JSON input
    #' @return the instance of Library
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`version`)) {
        self$`version` <- this_object$`version`
      }
      if (!is.null(this_object$`createdAt`)) {
        self$`createdAt` <- this_object$`createdAt`
      }
      if (!is.null(this_object$`updatedAt`)) {
        self$`updatedAt` <- this_object$`updatedAt`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Library in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                    ',
            self$`id`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                    ',
            self$`name`
          )
        },
        if (!is.null(self$`version`)) {
          sprintf(
            '"version":
            "%s"
                    ',
            self$`version`
          )
        },
        if (!is.null(self$`createdAt`)) {
          sprintf(
            '"createdAt":
            "%s"
                    ',
            self$`createdAt`
          )
        },
        if (!is.null(self$`updatedAt`)) {
          sprintf(
            '"updatedAt":
            "%s"
                    ',
            self$`updatedAt`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Library
    #'
    #' @param input_json the JSON input
    #' @return the instance of Library
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`name` <- this_object$`name`
      self$`version` <- this_object$`version`
      self$`createdAt` <- this_object$`createdAt`
      self$`updatedAt` <- this_object$`updatedAt`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to Library and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `name`
      if (!is.null(input_json$`name`)) {
        if (!(is.character(input_json$`name`) && length(input_json$`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", input_json$`name`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Library: the required field `name` is missing."))
      }
      # check the required field `version`
      if (!is.null(input_json$`version`)) {
        if (!(is.character(input_json$`version`) && length(input_json$`version`) == 1)) {
          stop(paste("Error! Invalid data for `version`. Must be a string:", input_json$`version`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Library: the required field `version` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Library
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        return(FALSE)
      }
      
      # check if the required `version` is null
      if (is.null(self$`version`)) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        invalid_fields["name"] <- "Non-nullable required field `name` cannot be null."
      }
      
      # check if the required `version` is null
      if (is.null(self$`version`)) {
        invalid_fields["version"] <- "Non-nullable required field `version` cannot be null."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# Library$unlock()
#
## Below is an example to define the print function
# Library$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# Library$lock()


#' Create a new Model
#'
#' @description
#' Model Class
#'
#' @docType class
#' @title Model
#' @description Model Class
#' @format An \code{R6Class} generator object
#' @field id  integer [optional]
#' @field name  character
#' @field description  character [optional]
#' @field type  \link{ModelType}
#' @field jaqpotpyVersion  character
#' @field doas  list(\link{Doa}) [optional]
#' @field libraries  list(\link{Library})
#' @field dependentFeatures  list(\link{Feature})
#' @field independentFeatures  list(\link{Feature})
#' @field sharedWithOrganizations  list(\link{Organization}) [optional]
#' @field visibility  \link{ModelVisibility}
#' @field task  \link{ModelTask}
#' @field torchConfig  named list(\link{AnyType}) [optional]
#' @field preprocessors  list(\link{Transformer}) [optional]
#' @field featurizers  list(\link{Transformer}) [optional]
#' @field rawPreprocessor A base64 representation of the raw preprocessor. character [optional]
#' @field rawModel A base64 representation of the raw model. character
#' @field creator  \link{User} [optional]
#' @field canEdit If the current user can edit the model character [optional]
#' @field isAdmin  character [optional]
#' @field selectedFeatures  list(character) [optional]
#' @field tags  character [optional]
#' @field legacyPredictionService  character [optional]
#' @field scores  \link{ModelScores} [optional]
#' @field rPbpkConfig  \link{RPbpkConfig} [optional]
#' @field createdAt The date and time when the feature was created. character [optional]
#' @field updatedAt The date and time when the feature was last updated. character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
Model <- R6::R6Class(
  "Model",
  public = list(
    `id` = NULL,
    `name` = NULL,
    `description` = NULL,
    `type` = NULL,
    `jaqpotpyVersion` = NULL,
    `doas` = NULL,
    `libraries` = NULL,
    `dependentFeatures` = NULL,
    `independentFeatures` = NULL,
    `sharedWithOrganizations` = NULL,
    `visibility` = NULL,
    `task` = NULL,
    `torchConfig` = NULL,
    `preprocessors` = NULL,
    `featurizers` = NULL,
    `rawPreprocessor` = NULL,
    `rawModel` = NULL,
    `creator` = NULL,
    `canEdit` = NULL,
    `isAdmin` = NULL,
    `selectedFeatures` = NULL,
    `tags` = NULL,
    `legacyPredictionService` = NULL,
    `scores` = NULL,
    `rPbpkConfig` = NULL,
    `createdAt` = NULL,
    `updatedAt` = NULL,
    
    #' @description
    #' Initialize a new Model class.
    #'
    #' @param name name
    #' @param type type
    #' @param jaqpotpyVersion jaqpotpyVersion
    #' @param libraries libraries
    #' @param dependentFeatures dependentFeatures
    #' @param independentFeatures independentFeatures
    #' @param visibility visibility
    #' @param task task
    #' @param rawModel A base64 representation of the raw model.
    #' @param id id
    #' @param description description
    #' @param doas doas
    #' @param sharedWithOrganizations sharedWithOrganizations
    #' @param torchConfig torchConfig
    #' @param preprocessors preprocessors
    #' @param featurizers featurizers
    #' @param rawPreprocessor A base64 representation of the raw preprocessor.
    #' @param creator creator
    #' @param canEdit If the current user can edit the model
    #' @param isAdmin isAdmin
    #' @param selectedFeatures selectedFeatures
    #' @param tags tags
    #' @param legacyPredictionService legacyPredictionService
    #' @param scores scores
    #' @param rPbpkConfig rPbpkConfig
    #' @param createdAt The date and time when the feature was created.
    #' @param updatedAt The date and time when the feature was last updated.
    #' @param ... Other optional arguments.
    initialize = function(`name`, `type`, `jaqpotpyVersion`, `libraries`, `dependentFeatures`, `independentFeatures`, `visibility`, `task`, `rawModel`, `id` = NULL, `description` = NULL, `doas` = NULL, `sharedWithOrganizations` = NULL, `torchConfig` = NULL, `preprocessors` = NULL, `featurizers` = NULL, `rawPreprocessor` = NULL, `creator` = NULL, `canEdit` = NULL, `isAdmin` = NULL, `selectedFeatures` = NULL, `tags` = NULL, `legacyPredictionService` = NULL, `scores` = NULL, `rPbpkConfig` = NULL, `createdAt` = NULL, `updatedAt` = NULL, ...) {
      if (!missing(`name`)) {
        if (!(is.character(`name`) && length(`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", `name`))
        }
        self$`name` <- `name`
      }
      if (!missing(`type`)) {
        if (!(`type`$getValue() %in% c("R_PBPK"))) {
          stop(paste("Error! \"", `type`, "\" cannot be assigned to `type`. Must be .", sep = ""))
        }
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
      if (!missing(`jaqpotpyVersion`)) {
        if (!(is.character(`jaqpotpyVersion`) && length(`jaqpotpyVersion`) == 1)) {
          stop(paste("Error! Invalid data for `jaqpotpyVersion`. Must be a string:", `jaqpotpyVersion`))
        }
        self$`jaqpotpyVersion` <- `jaqpotpyVersion`
      }
      if (!missing(`libraries`)) {
        stopifnot(is.vector(`libraries`), length(`libraries`) != 0)
        sapply(`libraries`, function(x) stopifnot(R6::is.R6(x)))
        self$`libraries` <- `libraries`
      }
      if (!missing(`dependentFeatures`)) {
        stopifnot(is.vector(`dependentFeatures`), length(`dependentFeatures`) != 0)
        sapply(`dependentFeatures`, function(x) stopifnot(R6::is.R6(x)))
        self$`dependentFeatures` <- `dependentFeatures`
      }
      if (!missing(`independentFeatures`)) {
        stopifnot(is.vector(`independentFeatures`), length(`independentFeatures`) != 0)
        sapply(`independentFeatures`, function(x) stopifnot(R6::is.R6(x)))
        self$`independentFeatures` <- `independentFeatures`
      }
      if (!missing(`visibility`)) {
        if (!(`visibility`$getValue()  %in%  c("PUBLIC", "SHARED_WITH", "PRIVATE"))) {
          stop(paste("Error! \"", `visibility`, "\" cannot be assigned to `visibility`. Must be .", sep = ""))
        }
        stopifnot(R6::is.R6(`visibility`))
        self$`visibility` <- `visibility`
      }
      if (!missing(`task`)) {
        if (!(`task`$getValue()  %in% c("REGRESSION", "BINARY_CLASSIFICATION", "MULTICLASS_CLASSIFICATION"))) {
          stop(paste("Error! \"", `task`, "\" cannot be assigned to `task`. Must be .", sep = ""))
        }
        stopifnot(R6::is.R6(`task`))
        self$`task` <- `task`
      }
      if (!missing(`rawModel`)) {
        self$`rawModel` <- `rawModel`
      }
      if (!is.null(`id`)) {
        if (!(is.numeric(`id`) && length(`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", `id`))
        }
        self$`id` <- `id`
      }
      if (!is.null(`description`)) {
        if (!(is.character(`description`) && length(`description`) == 1)) {
          stop(paste("Error! Invalid data for `description`. Must be a string:", `description`))
        }
        self$`description` <- `description`
      }
      if (!is.null(`doas`)) {
        stopifnot(is.vector(`doas`), length(`doas`) != 0)
        sapply(`doas`, function(x) stopifnot(R6::is.R6(x)))
        self$`doas` <- `doas`
      }
      if (!is.null(`sharedWithOrganizations`)) {
        stopifnot(is.vector(`sharedWithOrganizations`), length(`sharedWithOrganizations`) != 0)
        sapply(`sharedWithOrganizations`, function(x) stopifnot(R6::is.R6(x)))
        self$`sharedWithOrganizations` <- `sharedWithOrganizations`
      }
      if (!is.null(`torchConfig`)) {
        stopifnot(is.vector(`torchConfig`), length(`torchConfig`) != 0)
        sapply(`torchConfig`, function(x) stopifnot(R6::is.R6(x)))
        self$`torchConfig` <- `torchConfig`
      }
      if (!is.null(`preprocessors`)) {
        stopifnot(is.vector(`preprocessors`), length(`preprocessors`) != 0)
        sapply(`preprocessors`, function(x) stopifnot(R6::is.R6(x)))
        self$`preprocessors` <- `preprocessors`
      }
      if (!is.null(`featurizers`)) {
        stopifnot(is.vector(`featurizers`), length(`featurizers`) != 0)
        sapply(`featurizers`, function(x) stopifnot(R6::is.R6(x)))
        self$`featurizers` <- `featurizers`
      }
      if (!is.null(`rawPreprocessor`)) {
        self$`rawPreprocessor` <- `rawPreprocessor`
      }
      if (!is.null(`creator`)) {
        stopifnot(R6::is.R6(`creator`))
        self$`creator` <- `creator`
      }
      if (!is.null(`canEdit`)) {
        if (!(is.logical(`canEdit`) && length(`canEdit`) == 1)) {
          stop(paste("Error! Invalid data for `canEdit`. Must be a boolean:", `canEdit`))
        }
        self$`canEdit` <- `canEdit`
      }
      if (!is.null(`isAdmin`)) {
        if (!(is.logical(`isAdmin`) && length(`isAdmin`) == 1)) {
          stop(paste("Error! Invalid data for `isAdmin`. Must be a boolean:", `isAdmin`))
        }
        self$`isAdmin` <- `isAdmin`
      }
      if (!is.null(`selectedFeatures`)) {
        stopifnot(is.vector(`selectedFeatures`), length(`selectedFeatures`) != 0)
        sapply(`selectedFeatures`, function(x) stopifnot(is.character(x)))
        self$`selectedFeatures` <- `selectedFeatures`
      }
      if (!is.null(`tags`)) {
        if (!(is.character(`tags`) && length(`tags`) == 1)) {
          stop(paste("Error! Invalid data for `tags`. Must be a string:", `tags`))
        }
        self$`tags` <- `tags`
      }
      if (!is.null(`legacyPredictionService`)) {
        if (!(is.character(`legacyPredictionService`) && length(`legacyPredictionService`) == 1)) {
          stop(paste("Error! Invalid data for `legacyPredictionService`. Must be a string:", `legacyPredictionService`))
        }
        self$`legacyPredictionService` <- `legacyPredictionService`
      }
      if (!is.null(`scores`)) {
        stopifnot(R6::is.R6(`scores`))
        self$`scores` <- `scores`
      }
      if (!is.null(`rPbpkConfig`)) {
        stopifnot(R6::is.R6(`rPbpkConfig`))
        self$`rPbpkConfig` <- `rPbpkConfig`
      }
      if (!is.null(`createdAt`)) {
        if (!is.character(`createdAt`)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", `createdAt`))
        }
        self$`createdAt` <- `createdAt`
      }
      if (!is.null(`updatedAt`)) {
        if (!is.character(`updatedAt`)) {
          stop(paste("Error! Invalid data for `updatedAt`. Must be a string:", `updatedAt`))
        }
        self$`updatedAt` <- `updatedAt`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Model in JSON format
    toJSON = function() {
      ModelObject <- list()
      if (!is.null(self$`id`)) {
        ModelObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`name`)) {
        ModelObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`description`)) {
        ModelObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`type`)) {
        ModelObject[["type"]] <-
          self$`type`$getValue()
      }
      if (!is.null(self$`jaqpotpyVersion`)) {
        ModelObject[["jaqpotpyVersion"]] <-
          self$`jaqpotpyVersion`
      }
      if (!is.null(self$`doas`)) {
        ModelObject[["doas"]] <-
          lapply(self$`doas`, function(x) x$toJSON())
      }
      if (!is.null(self$`libraries`)) {
        ModelObject[["libraries"]] <-
          lapply(self$`libraries`, function(x) x$toJSON())
      }
      if (!is.null(self$`dependentFeatures`)) {
        ModelObject[["dependentFeatures"]] <-
          lapply(self$`dependentFeatures`, function(x) x$toJSON())
      }
      if (!is.null(self$`independentFeatures`)) {
        ModelObject[["independentFeatures"]] <-
          lapply(self$`independentFeatures`, function(x) x$toJSON())
      }
      if (!is.null(self$`sharedWithOrganizations`)) {
        ModelObject[["sharedWithOrganizations"]] <-
          lapply(self$`sharedWithOrganizations`, function(x) x$getValue())
      }
      if (!is.null(self$`visibility`)) {
        ModelObject[["visibility"]] <-
          self$`visibility`$getValue()
      }
      if (!is.null(self$`task`)) {
        ModelObject[["task"]] <-
          self$`task`$getValue()
      }
      if (!is.null(self$`torchConfig`)) {
        ModelObject[["torchConfig"]] <-
          lapply(self$`torchConfig`, function(x) x$toJSON())
      }
      if (!is.null(self$`preprocessors`)) {
        ModelObject[["preprocessors"]] <-
          lapply(self$`preprocessors`, function(x) x$toJSON())
      }
      if (!is.null(self$`featurizers`)) {
        ModelObject[["featurizers"]] <-
          lapply(self$`featurizers`, function(x) x$toJSON())
      }
      if (!is.null(self$`rawPreprocessor`)) {
        ModelObject[["rawPreprocessor"]] <-
          self$`rawPreprocessor`
      }
      if (!is.null(self$`rawModel`)) {
        ModelObject[["rawModel"]] <-
          self$`rawModel`
      }
      if (!is.null(self$`creator`)) {
        ModelObject[["creator"]] <-
          self$`creator`$toJSON()
      }
      if (!is.null(self$`canEdit`)) {
        ModelObject[["canEdit"]] <-
          self$`canEdit`
      }
      if (!is.null(self$`isAdmin`)) {
        ModelObject[["isAdmin"]] <-
          self$`isAdmin`
      }
      if (!is.null(self$`selectedFeatures`)) {
        ModelObject[["selectedFeatures"]] <-
          self$`selectedFeatures`
      }
      if (!is.null(self$`tags`)) {
        ModelObject[["tags"]] <-
          self$`tags`
      }
      if (!is.null(self$`legacyPredictionService`)) {
        ModelObject[["legacyPredictionService"]] <-
          self$`legacyPredictionService`
      }
      if (!is.null(self$`scores`)) {
        ModelObject[["scores"]] <-
          self$`scores`$toJSON()
      }
      if (!is.null(self$`rPbpkConfig`)) {
        ModelObject[["rPbpkConfig"]] <-
          self$`rPbpkConfig`$toJSON()
      }
      if (!is.null(self$`createdAt`)) {
        ModelObject[["createdAt"]] <-
          self$`createdAt`
      }
      if (!is.null(self$`updatedAt`)) {
        ModelObject[["updatedAt"]] <-
          self$`updatedAt`
      }
      ModelObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Model
    #'
    #' @param input_json the JSON input
    #' @return the instance of Model
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`type`)) {
        `type_object` <- ModelType$new()
        `type_object`$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
        self$`type` <- `type_object`
      }
      if (!is.null(this_object$`jaqpotpyVersion`)) {
        self$`jaqpotpyVersion` <- this_object$`jaqpotpyVersion`
      }
      if (!is.null(this_object$`doas`)) {
        self$`doas` <- ApiClient$new()$deserializeObj(this_object$`doas`, "array[Doa]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`libraries`)) {
        self$`libraries` <- ApiClient$new()$deserializeObj(this_object$`libraries`, "array[Library]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`dependentFeatures`)) {
        self$`dependentFeatures` <- ApiClient$new()$deserializeObj(this_object$`dependentFeatures`, "array[Feature]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`independentFeatures`)) {
        self$`independentFeatures` <- ApiClient$new()$deserializeObj(this_object$`independentFeatures`, "array[Feature]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`sharedWithOrganizations`)) {
        self$`sharedWithOrganizations` <- ApiClient$new()$deserializeObj(this_object$`sharedWithOrganizations`, "array[Organization]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`visibility`)) {
        `visibility_object` <- ModelVisibility$new()
        `visibility_object`$fromJSON(jsonlite::toJSON(this_object$`visibility`, auto_unbox = TRUE, digits = NA))
        self$`visibility` <- `visibility_object`
      }
      if (!is.null(this_object$`task`)) {
        `task_object` <- ModelTask$new()
        `task_object`$fromJSON(jsonlite::toJSON(this_object$`task`, auto_unbox = TRUE, digits = NA))
        self$`task` <- `task_object`
      }
      if (!is.null(this_object$`torchConfig`)) {
        self$`torchConfig` <- ApiClient$new()$deserializeObj(this_object$`torchConfig`, "map(AnyType)", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`preprocessors`)) {
        self$`preprocessors` <- ApiClient$new()$deserializeObj(this_object$`preprocessors`, "array[Transformer]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`featurizers`)) {
        self$`featurizers` <- ApiClient$new()$deserializeObj(this_object$`featurizers`, "array[Transformer]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`rawPreprocessor`)) {
        self$`rawPreprocessor` <- this_object$`rawPreprocessor`
      }
      if (!is.null(this_object$`rawModel`)) {
        self$`rawModel` <- this_object$`rawModel`
      }
      if (!is.null(this_object$`creator`)) {
        `creator_object` <- User$new()
        `creator_object`$fromJSON(jsonlite::toJSON(this_object$`creator`, auto_unbox = TRUE, digits = NA))
        self$`creator` <- `creator_object`
      }
      if (!is.null(this_object$`canEdit`)) {
        self$`canEdit` <- this_object$`canEdit`
      }
      if (!is.null(this_object$`isAdmin`)) {
        self$`isAdmin` <- this_object$`isAdmin`
      }
      if (!is.null(this_object$`selectedFeatures`)) {
        self$`selectedFeatures` <- ApiClient$new()$deserializeObj(this_object$`selectedFeatures`, "array[character]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`tags`)) {
        self$`tags` <- this_object$`tags`
      }
      if (!is.null(this_object$`legacyPredictionService`)) {
        self$`legacyPredictionService` <- this_object$`legacyPredictionService`
      }
      if (!is.null(this_object$`scores`)) {
        `scores_object` <- ModelScores$new()
        `scores_object`$fromJSON(jsonlite::toJSON(this_object$`scores`, auto_unbox = TRUE, digits = NA))
        self$`scores` <- `scores_object`
      }
      if (!is.null(this_object$`rPbpkConfig`)) {
        `rpbpkconfig_object` <- RPbpkConfig$new()
        `rpbpkconfig_object`$fromJSON(jsonlite::toJSON(this_object$`rPbpkConfig`, auto_unbox = TRUE, digits = NA))
        self$`rPbpkConfig` <- `rpbpkconfig_object`
      }
      if (!is.null(this_object$`createdAt`)) {
        self$`createdAt` <- this_object$`createdAt`
      }
      if (!is.null(this_object$`updatedAt`)) {
        self$`updatedAt` <- this_object$`updatedAt`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return Model in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                    ',
            self$`id`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                    ',
            self$`name`
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
            '"description":
            "%s"
                    ',
            self$`description`
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
            '"type":
          %s
          ',
            jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`jaqpotpyVersion`)) {
          sprintf(
            '"jaqpotpyVersion":
            "%s"
                    ',
            self$`jaqpotpyVersion`
          )
        },
        if (!is.null(self$`doas`)) {
          sprintf(
            '"doas":
          [%s]
',
            paste(sapply(self$`doas`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`libraries`)) {
          sprintf(
            '"libraries":
          [%s]
',
            paste(sapply(self$`libraries`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`dependentFeatures`)) {
          sprintf(
            '"dependentFeatures":
          [%s]
',
            paste(sapply(self$`dependentFeatures`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`independentFeatures`)) {
          sprintf(
            '"independentFeatures":
          [%s]
',
            paste(sapply(self$`independentFeatures`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`sharedWithOrganizations`)) {
          sprintf(
            '"sharedWithOrganizations":
          [%s]
',
            paste(sapply(self$`sharedWithOrganizations`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`visibility`)) {
          sprintf(
            '"visibility":
          %s
          ',
            jsonlite::toJSON(self$`visibility`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`task`)) {
          sprintf(
            '"task":
          %s
          ',
            jsonlite::toJSON(self$`task`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`torchConfig`)) {
          sprintf(
            '"torchConfig":
          %s
',
            jsonlite::toJSON(lapply(self$`torchConfig`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`preprocessors`)) {
          sprintf(
            '"preprocessors":
          [%s]
',
            paste(sapply(self$`preprocessors`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`featurizers`)) {
          sprintf(
            '"featurizers":
          [%s]
',
            paste(sapply(self$`featurizers`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`rawPreprocessor`)) {
          sprintf(
            '"rawPreprocessor":
            "%s"
                    ',
            self$`rawPreprocessor`
          )
        },
        if (!is.null(self$`rawModel`)) {
          sprintf(
            '"rawModel":
            "%s"
                    ',
            self$`rawModel`
          )
        },
        if (!is.null(self$`creator`)) {
          sprintf(
            '"creator":
          %s
          ',
            jsonlite::toJSON(self$`creator`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`canEdit`)) {
          sprintf(
            '"canEdit":
            %s
                    ',
            tolower(self$`canEdit`)
          )
        },
        if (!is.null(self$`isAdmin`)) {
          sprintf(
            '"isAdmin":
            %s
                    ',
            tolower(self$`isAdmin`)
          )
        },
        if (!is.null(self$`selectedFeatures`)) {
          sprintf(
            '"selectedFeatures":
             [%s]
          ',
            paste(unlist(lapply(self$`selectedFeatures`, function(x) paste0('"', x, '"'))), collapse = ",")
          )
        },
        if (!is.null(self$`tags`)) {
          sprintf(
            '"tags":
            "%s"
                    ',
            self$`tags`
          )
        },
        if (!is.null(self$`legacyPredictionService`)) {
          sprintf(
            '"legacyPredictionService":
            "%s"
                    ',
            self$`legacyPredictionService`
          )
        },
        if (!is.null(self$`scores`)) {
          sprintf(
            '"scores":
          %s
          ',
            jsonlite::toJSON(self$`scores`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`rPbpkConfig`)) {
          sprintf(
            '"rPbpkConfig":
          %s
          ',
            jsonlite::toJSON(self$`rPbpkConfig`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`createdAt`)) {
          sprintf(
            '"createdAt":
            "%s"
                    ',
            self$`createdAt`
          )
        },
        if (!is.null(self$`updatedAt`)) {
          sprintf(
            '"updatedAt":
            "%s"
                    ',
            self$`updatedAt`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of Model
    #'
    #' @param input_json the JSON input
    #' @return the instance of Model
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`name` <- this_object$`name`
      self$`description` <- this_object$`description`
      self$`type` <- ModelType$new()$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
      self$`jaqpotpyVersion` <- this_object$`jaqpotpyVersion`
      self$`doas` <- ApiClient$new()$deserializeObj(this_object$`doas`, "array[Doa]", loadNamespace("openapi"))
      self$`libraries` <- ApiClient$new()$deserializeObj(this_object$`libraries`, "array[Library]", loadNamespace("openapi"))
      self$`dependentFeatures` <- ApiClient$new()$deserializeObj(this_object$`dependentFeatures`, "array[Feature]", loadNamespace("openapi"))
      self$`independentFeatures` <- ApiClient$new()$deserializeObj(this_object$`independentFeatures`, "array[Feature]", loadNamespace("openapi"))
      self$`sharedWithOrganizations` <- ApiClient$new()$deserializeObj(this_object$`sharedWithOrganizations`, "array[Organization]", loadNamespace("openapi"))
      self$`visibility` <- ModelVisibility$new()$fromJSON(jsonlite::toJSON(this_object$`visibility`, auto_unbox = TRUE, digits = NA))
      self$`task` <- ModelTask$new()$fromJSON(jsonlite::toJSON(this_object$`task`, auto_unbox = TRUE, digits = NA))
      self$`torchConfig` <- ApiClient$new()$deserializeObj(this_object$`torchConfig`, "map(AnyType)", loadNamespace("openapi"))
      self$`preprocessors` <- ApiClient$new()$deserializeObj(this_object$`preprocessors`, "array[Transformer]", loadNamespace("openapi"))
      self$`featurizers` <- ApiClient$new()$deserializeObj(this_object$`featurizers`, "array[Transformer]", loadNamespace("openapi"))
      self$`rawPreprocessor` <- this_object$`rawPreprocessor`
      self$`rawModel` <- this_object$`rawModel`
      self$`creator` <- User$new()$fromJSON(jsonlite::toJSON(this_object$`creator`, auto_unbox = TRUE, digits = NA))
      self$`canEdit` <- this_object$`canEdit`
      self$`isAdmin` <- this_object$`isAdmin`
      self$`selectedFeatures` <- ApiClient$new()$deserializeObj(this_object$`selectedFeatures`, "array[character]", loadNamespace("openapi"))
      self$`tags` <- this_object$`tags`
      self$`legacyPredictionService` <- this_object$`legacyPredictionService`
      self$`scores` <- ModelScores$new()$fromJSON(jsonlite::toJSON(this_object$`scores`, auto_unbox = TRUE, digits = NA))
      self$`rPbpkConfig` <- RPbpkConfig$new()$fromJSON(jsonlite::toJSON(this_object$`rPbpkConfig`, auto_unbox = TRUE, digits = NA))
      self$`createdAt` <- this_object$`createdAt`
      self$`updatedAt` <- this_object$`updatedAt`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to Model and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `name`
      if (!is.null(input_json$`name`)) {
        if (!(is.character(input_json$`name`) && length(input_json$`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", input_json$`name`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `name` is missing."))
      }
      # check the required field `type`
      if (!is.null(input_json$`type`)) {
        stopifnot(R6::is.R6(input_json$`type`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `type` is missing."))
      }
      # check the required field `jaqpotpyVersion`
      if (!is.null(input_json$`jaqpotpyVersion`)) {
        if (!(is.character(input_json$`jaqpotpyVersion`) && length(input_json$`jaqpotpyVersion`) == 1)) {
          stop(paste("Error! Invalid data for `jaqpotpyVersion`. Must be a string:", input_json$`jaqpotpyVersion`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `jaqpotpyVersion` is missing."))
      }
      # check the required field `libraries`
      if (!is.null(input_json$`libraries`)) {
        stopifnot(is.vector(input_json$`libraries`), length(input_json$`libraries`) != 0)
        tmp <- sapply(input_json$`libraries`, function(x) stopifnot(R6::is.R6(x)))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `libraries` is missing."))
      }
      # check the required field `dependentFeatures`
      if (!is.null(input_json$`dependentFeatures`)) {
        stopifnot(is.vector(input_json$`dependentFeatures`), length(input_json$`dependentFeatures`) != 0)
        tmp <- sapply(input_json$`dependentFeatures`, function(x) stopifnot(R6::is.R6(x)))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `dependentFeatures` is missing."))
      }
      # check the required field `independentFeatures`
      if (!is.null(input_json$`independentFeatures`)) {
        stopifnot(is.vector(input_json$`independentFeatures`), length(input_json$`independentFeatures`) != 0)
        tmp <- sapply(input_json$`independentFeatures`, function(x) stopifnot(R6::is.R6(x)))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `independentFeatures` is missing."))
      }
      # check the required field `visibility`
      if (!is.null(input_json$`visibility`)) {
        stopifnot(R6::is.R6(input_json$`visibility`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `visibility` is missing."))
      }
      # check the required field `task`
      if (!is.null(input_json$`task`)) {
        stopifnot(R6::is.R6(input_json$`task`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `task` is missing."))
      }
      # check the required field `rawModel`
      if (!is.null(input_json$`rawModel`)) {
      } else {
        stop(paste("The JSON input `", input, "` is invalid for Model: the required field `rawModel` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of Model
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        return(FALSE)
      }
      
      if (nchar(self$`name`) > 255) {
        return(FALSE)
      }
      if (nchar(self$`name`) < 3) {
        return(FALSE)
      }
      
      if (nchar(self$`description`) > 50000) {
        return(FALSE)
      }
      if (nchar(self$`description`) < 3) {
        return(FALSE)
      }
      
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        return(FALSE)
      }
      
      # check if the required `jaqpotpyVersion` is null
      if (is.null(self$`jaqpotpyVersion`)) {
        return(FALSE)
      }
      
      if (length(self$`doas`) > 50) {
        return(FALSE)
      }
      
      # check if the required `libraries` is null
      if (is.null(self$`libraries`)) {
        return(FALSE)
      }
      
      if (length(self$`libraries`) > 1000) {
        return(FALSE)
      }
      
      # check if the required `dependentFeatures` is null
      if (is.null(self$`dependentFeatures`)) {
        return(FALSE)
      }
      
      if (length(self$`dependentFeatures`) > 1000) {
        return(FALSE)
      }
      
      # check if the required `independentFeatures` is null
      if (is.null(self$`independentFeatures`)) {
        return(FALSE)
      }
      
      if (length(self$`independentFeatures`) > 1000) {
        return(FALSE)
      }
      
      # check if the required `visibility` is null
      if (is.null(self$`visibility`)) {
        return(FALSE)
      }
      
      # check if the required `task` is null
      if (is.null(self$`task`)) {
        return(FALSE)
      }
      
      if (length(self$`torchConfig`) > 20) {
        return(FALSE)
      }
      
      if (length(self$`preprocessors`) > 50) {
        return(FALSE)
      }
      
      if (length(self$`featurizers`) > 50) {
        return(FALSE)
      }
      
      if (nchar(self$`rawPreprocessor`) > 10000000) {
        return(FALSE)
      }
      
      # check if the required `rawModel` is null
      if (is.null(self$`rawModel`)) {
        return(FALSE)
      }
      
      if (nchar(self$`rawModel`) > 10000000) {
        return(FALSE)
      }
      
      if (length(self$`selectedFeatures`) > 1000) {
        return(FALSE)
      }
      
      if (nchar(self$`tags`) > 1000) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        invalid_fields["name"] <- "Non-nullable required field `name` cannot be null."
      }
      
      if (nchar(self$`name`) > 255) {
        invalid_fields["name"] <- "Invalid length for `name`, must be smaller than or equal to 255."
      }
      if (nchar(self$`name`) < 3) {
        invalid_fields["name"] <- "Invalid length for `name`, must be bigger than or equal to 3."
      }
      
      if (nchar(self$`description`) > 50000) {
        invalid_fields["description"] <- "Invalid length for `description`, must be smaller than or equal to 50000."
      }
      if (nchar(self$`description`) < 3) {
        invalid_fields["description"] <- "Invalid length for `description`, must be bigger than or equal to 3."
      }
      
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        invalid_fields["type"] <- "Non-nullable required field `type` cannot be null."
      }
      
      # check if the required `jaqpotpyVersion` is null
      if (is.null(self$`jaqpotpyVersion`)) {
        invalid_fields["jaqpotpyVersion"] <- "Non-nullable required field `jaqpotpyVersion` cannot be null."
      }
      
      if (length(self$`doas`) > 50) {
        invalid_fields["doas"] <- "Invalid length for `doas`, number of items must be less than or equal to 50."
      }
      
      # check if the required `libraries` is null
      if (is.null(self$`libraries`)) {
        invalid_fields["libraries"] <- "Non-nullable required field `libraries` cannot be null."
      }
      
      if (length(self$`libraries`) > 1000) {
        invalid_fields["libraries"] <- "Invalid length for `libraries`, number of items must be less than or equal to 1000."
      }
      
      # check if the required `dependentFeatures` is null
      if (is.null(self$`dependentFeatures`)) {
        invalid_fields["dependentFeatures"] <- "Non-nullable required field `dependentFeatures` cannot be null."
      }
      
      if (length(self$`dependentFeatures`) > 1000) {
        invalid_fields["dependentFeatures"] <- "Invalid length for `dependentFeatures`, number of items must be less than or equal to 1000."
      }
      
      # check if the required `independentFeatures` is null
      if (is.null(self$`independentFeatures`)) {
        invalid_fields["independentFeatures"] <- "Non-nullable required field `independentFeatures` cannot be null."
      }
      
      if (length(self$`independentFeatures`) > 1000) {
        invalid_fields["independentFeatures"] <- "Invalid length for `independentFeatures`, number of items must be less than or equal to 1000."
      }
      
      # check if the required `visibility` is null
      if (is.null(self$`visibility`)) {
        invalid_fields["visibility"] <- "Non-nullable required field `visibility` cannot be null."
      }
      
      # check if the required `task` is null
      if (is.null(self$`task`)) {
        invalid_fields["task"] <- "Non-nullable required field `task` cannot be null."
      }
      
      if (length(self$`torchConfig`) > 20) {
        invalid_fields["torchConfig"] <- "Invalid length for `torchConfig`, number of items must be less than or equal to 20."
      }
      
      if (length(self$`preprocessors`) > 50) {
        invalid_fields["preprocessors"] <- "Invalid length for `preprocessors`, number of items must be less than or equal to 50."
      }
      
      if (length(self$`featurizers`) > 50) {
        invalid_fields["featurizers"] <- "Invalid length for `featurizers`, number of items must be less than or equal to 50."
      }
      
      if (nchar(self$`rawPreprocessor`) > 10000000) {
        invalid_fields["rawPreprocessor"] <- "Invalid length for `rawPreprocessor`, must be smaller than or equal to 10000000."
      }
      
      # check if the required `rawModel` is null
      if (is.null(self$`rawModel`)) {
        invalid_fields["rawModel"] <- "Non-nullable required field `rawModel` cannot be null."
      }
      
      if (nchar(self$`rawModel`) > 10000000) {
        invalid_fields["rawModel"] <- "Invalid length for `rawModel`, must be smaller than or equal to 10000000."
      }
      
      if (length(self$`selectedFeatures`) > 1000) {
        invalid_fields["selectedFeatures"] <- "Invalid length for `selectedFeatures`, number of items must be less than or equal to 1000."
      }
      
      if (nchar(self$`tags`) > 1000) {
        invalid_fields["tags"] <- "Invalid length for `tags`, must be smaller than or equal to 1000."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# Model$unlock()
#
## Below is an example to define the print function
# Model$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# Model$lock()


#' Jaqpot API
#'
#' A modern RESTful API for model management and prediction services, built using Spring Boot and Kotlin. Supports seamless integration with machine learning workflows.
#'
#' The version of the OpenAPI document: 1.0.0
#' Contact: upci.ntua@gmail.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Model operations
#' @description ModelApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateModel  ####################
#'
#' library(openapi)
#' var_model <- Model$new("name_example", ModelType$new(), "jaqpotpyVersion_example", c(Library$new("name_example", "version_example", 123, "createdAt_example", "updatedAt_example")), c(Feature$new("key_example", "name_example", FeatureType$new(), 123, "units_example", "range_example", "description_example", "DEPENDENT", "visible_example", c(FeaturePossibleValue$new("key_example", "value_example")), "createdAt_example", "updatedAt_example")), c(Feature$new("key_example", "name_example", FeatureType$new(), 123, "units_example", "range_example", "description_example", "DEPENDENT", "visible_example", c(FeaturePossibleValue$new("key_example", "value_example")), "createdAt_example", "updatedAt_example")), ModelVisibility$new(), ModelTask$new(), "rawModel_example", 123, "description_example", c(Doa$new(DoaMethod$new(), c(key = TODO), 123, "createdAt_example", "updatedAt_example")), c(Organization$new("name_example", OrganizationVisibility$new(), "contactEmail_example", 123, User$new("id_example", "username_example", "firstName_example", "lastName_example", "email_example", "emailVerified_example"), "description_example", c(OrganizationUser$new("userId_example", OrganizationUserAssociationType$new(), 123, "username_example", "email_example")), "contactPhone_example", "website_example", "address_example", "canEdit_example", "isMember_example", "created_at_example", "updated_at_example")), c(key = TODO), c(Transformer$new("name_example", c(key = TODO), 123)), c(Transformer$new("name_example", c(key = TODO), 123)), "rawPreprocessor_example", User$new("id_example", "username_example", "firstName_example", "lastName_example", "email_example", "emailVerified_example"), "canEdit_example", "isAdmin_example", c("selectedFeatures_example"), "tags_example", "legacyPredictionService_example", Model_scores$new(c(Scores$new(RegressionScores$new("yName_example", 123, 123, 123, 123), BinaryClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123))), MulticlassClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123))))), c(Scores$new(RegressionScores$new("yName_example", 123, 123, 123, 123), BinaryClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123))), MulticlassClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123))))), c(Scores$new(RegressionScores$new("yName_example", 123, 123, 123, 123), BinaryClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123))), MulticlassClassificationScores$new("yName_example", c("labels_example"), 123, 123, 123, c(123), c(123), c(123), c(123), 123, c(c(123)))))), RPbpkConfig$new("odeSolver_example"), "createdAt_example", "updatedAt_example") # Model |
#'
#' #Create a new model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$CreateModel(var_model)
#'
#'
#' ####################  DeleteModelById  ####################
#'
#' library(openapi)
#' var_id <- 0 # integer | The ID of the model to delete
#'
#' #Delete a Model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$DeleteModelById(var_id)
#'
#'
#' ####################  GetLegacyModelById  ####################
#'
#' library(openapi)
#' var_id <- "id_example" # character | The ID of the model to retrieve
#'
#' #Get a legacy model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetLegacyModelById(var_iddata_file = "result.txt")
#' result <- api_instance$GetLegacyModelById(var_id)
#' dput(result)
#'
#'
#' ####################  GetModelById  ####################
#'
#' library(openapi)
#' var_id <- 0 # integer | The ID of the model to retrieve
#'
#' #Get a Model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetModelById(var_iddata_file = "result.txt")
#' result <- api_instance$GetModelById(var_id)
#' dput(result)
#'
#'
#' ####################  GetModels  ####################
#'
#' library(openapi)
#' var_page <- 0 # integer |  (Optional)
#' var_size <- 10 # integer |  (Optional)
#' var_sort <- c("inner_example") # array[character] |  (Optional)
#'
#' #Get paginated models
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetModels(page = var_page, size = var_size, sort = var_sortdata_file = "result.txt")
#' result <- api_instance$GetModels(page = var_page, size = var_size, sort = var_sort)
#' dput(result)
#'
#'
#' ####################  GetSharedModels  ####################
#'
#' library(openapi)
#' var_page <- 0 # integer |  (Optional)
#' var_size <- 10 # integer |  (Optional)
#' var_sort <- c("inner_example") # array[character] |  (Optional)
#' var_organization_id <- 56 # integer |  (Optional)
#'
#' #Get paginated shared models
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetSharedModels(page = var_page, size = var_size, sort = var_sort, organization_id = var_organization_iddata_file = "result.txt")
#' result <- api_instance$GetSharedModels(page = var_page, size = var_size, sort = var_sort, organization_id = var_organization_id)
#' dput(result)
#'
#'
#' ####################  PartiallyUpdateModel  ####################
#'
#' library(openapi)
#' var_id <- 56 # integer |
#' var_partially_update_model_request <- partiallyUpdateModel_request$new("name_example", ModelVisibility$new(), ModelTask$new(), "description_example", "tags_example", c(123)) # PartiallyUpdateModelRequest |
#'
#' #Partially update specific fields of a model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$PartiallyUpdateModel(var_id, var_partially_update_model_requestdata_file = "result.txt")
#' result <- api_instance$PartiallyUpdateModel(var_id, var_partially_update_model_request)
#' dput(result)
#'
#'
#' ####################  PredictWithModel  ####################
#'
#' library(openapi)
#' var_model_id <- 0 # integer | The ID of the model to use for prediction
#' var_dataset <- Dataset$new(DatasetType$new(), "ARRAY", c(TODO), 123, c(TODO), "CREATED", "failureReason_example", "userId_example", 123, "modelName_example", "executedAt_example", "executionFinishedAt_example", "createdAt_example", "updatedAt_example") # Dataset |
#'
#' #Predict with Model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$PredictWithModel(var_model_id, var_dataset)
#'
#'
#' ####################  PredictWithModelCSV  ####################
#'
#' library(openapi)
#' var_model_id <- 0 # integer | The ID of the model to use for prediction
#' var_dataset_csv <- DatasetCSV$new(DatasetType$new(), "inputFile_example", 123, c(TODO), "CREATED", "failureReason_example", 123, "modelName_example", "executedAt_example", "executionFinishedAt_example", "createdAt_example", "updatedAt_example") # DatasetCSV |
#'
#' #Predict using CSV with Model
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' api_instance$PredictWithModelCSV(var_model_id, var_dataset_csv)
#'
#'
#' ####################  SearchModels  ####################
#'
#' library(openapi)
#' var_query <- "query_example" # character |
#' var_page <- 0 # integer |  (Optional)
#' var_size <- 10 # integer |  (Optional)
#'
#' #Search for models
#' api_instance <- ModelApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchModels(var_query, page = var_page, size = var_sizedata_file = "result.txt")
#' result <- api_instance$SearchModels(var_query, page = var_page, size = var_size)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @keywords internal
#' @noRd
ModelApi <- R6::R6Class(
  "ModelApi",
  public = list(
    api_client = NULL,
    
    #' @description
    #' Initialize a new ModelApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    
    #' @description
    #' Create a new model
    #'
    #' @param model the model
    #' @param ... Other optional arguments
    #'
    #' @return void
    CreateModel = function(model, ...) {
      local_var_response <- self$CreateModelWithHttpInfo(model, ...)
      
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },
    
    #' @description
    #' Create a new model
    #'
    #' @param model the model
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    CreateModelWithHttpInfo = function(model, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`model`)) {
        stop("Missing required parameter `model`.")
      }
      
      
      if (!is.null(`model`)) {
        local_var_body <- jsonlite::toJSON(`model`$toJSON(), auto_unbox = TRUE, digits = NA)
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/models"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "POST",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        api_url <-local_var_resp$headers$Location
        model_id <- sub(".*/models/([0-9]+).*", "\\1", api_url)
        dashboard_url <- paste0("https://app.jaqpot.org/dashboard/models/", model_id, "/")
        
        print(paste0("Model has been deployed on the Jaqpot platform. Visit model at: ", dashboard_url))
        #local_var_resp$content <- NULL
        return(local_var_resp)
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
        print(paste0("Error, status code ", local_var_resp$status_code))
        return(local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
        print(paste0("API client error, status code ", local_var_resp$status_code))
        return(local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
          print(paste0("API server error, status code ", local_var_resp$status_code))
        }
        return(local_var_resp)
      }
    },
    
    #' @description
    #' Delete a Model
    #'
    #' @param id The ID of the model to delete
    #' @param ... Other optional arguments
    #'
    #' @return void
    DeleteModelById = function(id, ...) {
      local_var_response <- self$DeleteModelByIdWithHttpInfo(id, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Delete a Model
    #'
    #' @param id The ID of the model to delete
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    DeleteModelByIdWithHttpInfo = function(id, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }
      
      
      local_var_url_path <- "/v1/models/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "DELETE",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Get a legacy model
    #'
    #' @param id The ID of the model to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return Model
    GetLegacyModelById = function(id, data_file = NULL, ...) {
      local_var_response <- self$GetLegacyModelByIdWithHttpInfo(id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get a legacy model
    #'
    #' @param id The ID of the model to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (Model) with additional information such as HTTP status code, headers
    GetLegacyModelByIdWithHttpInfo = function(id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }
      
      
      local_var_url_path <- "/v1/models/legacy/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "Model", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Get a Model
    #'
    #' @param id The ID of the model to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return Model
    GetModelById = function(id, data_file = NULL, ...) {
      local_var_response <- self$GetModelByIdWithHttpInfo(id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get a Model
    #'
    #' @param id The ID of the model to retrieve
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (Model) with additional information such as HTTP status code, headers
    GetModelByIdWithHttpInfo = function(id, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }
      
      
      local_var_url_path <- "/v1/models/{id}"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "Model", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Get paginated models
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return GetModels200Response
    GetModels = function(page = 0, size = 10, sort = NULL, data_file = NULL, ...) {
      local_var_response <- self$GetModelsWithHttpInfo(page, size, sort, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get paginated models
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (GetModels200Response) with additional information such as HTTP status code, headers
    GetModelsWithHttpInfo = function(page = 0, size = 10, sort = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      
      
      
      query_params[["page"]] <- `page`
      
      query_params[["size"]] <- `size`
      
      # explore
      for (query_item in `sort`) {
        query_params[["sort"]] <- c(query_params[["sort"]], list(`sort` = query_item))
      }
      
      local_var_url_path <- "/v1/user/models"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "GetModels200Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Get paginated shared models
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param organization_id (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return GetModels200Response
    GetSharedModels = function(page = 0, size = 10, sort = NULL, organization_id = NULL, data_file = NULL, ...) {
      local_var_response <- self$GetSharedModelsWithHttpInfo(page, size, sort, organization_id, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Get paginated shared models
    #'
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param sort (optional) No description
    #' @param organization_id (optional) No description
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (GetModels200Response) with additional information such as HTTP status code, headers
    GetSharedModelsWithHttpInfo = function(page = 0, size = 10, sort = NULL, organization_id = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      
      
      
      
      query_params[["page"]] <- `page`
      
      query_params[["size"]] <- `size`
      
      # explore
      for (query_item in `sort`) {
        query_params[["sort"]] <- c(query_params[["sort"]], list(`sort` = query_item))
      }
      
      query_params[["organizationId"]] <- `organization_id`
      
      local_var_url_path <- "/v1/user/shared-models"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "GetModels200Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Partially update specific fields of a model
    #'
    #' @param id the model id
    #' @param partially_update_model_request the request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return Model
    PartiallyUpdateModel = function(id, partially_update_model_request, data_file = NULL, ...) {
      local_var_response <- self$PartiallyUpdateModelWithHttpInfo(id, partially_update_model_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Partially update specific fields of a model
    #'
    #' @param id the model id
    #' @param partially_update_model_request the request
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (Model) with additional information such as HTTP status code, headers
    PartiallyUpdateModelWithHttpInfo = function(id, partially_update_model_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }
      
      if (missing(`partially_update_model_request`)) {
        stop("Missing required parameter `partially_update_model_request`.")
      }
      
      
      
      if (!is.null(`partially_update_model_request`)) {
        local_var_body <- `partially_update_model_request`$toJSONString()
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/models/{id}/partial"
      if (!missing(`id`)) {
        local_var_url_path <- gsub("\\{id\\}", URLencode(as.character(`id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "PATCH",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "Model", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Predict with Model
    #'
    #' @param model_id The ID of the model to use for prediction
    #' @param dataset the dataset
    #' @param ... Other optional arguments
    #'
    #' @return void
    PredictWithModel = function(model_id, dataset, ...) {
      local_var_response <- self$PredictWithModelWithHttpInfo(model_id, dataset, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },
    
    #' @description
    #' Predict with Model
    #'
    #' @param model_id The ID of the model to use for prediction
    #' @param dataset the dataset
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    PredictWithModelWithHttpInfo = function(model_id, dataset, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`model_id`)) {
        stop("Missing required parameter `model_id`.")
      }
      
      if (missing(`dataset`)) {
        stop("Missing required parameter `dataset`.")
      }
      
      
      
      if (!is.null(`dataset`)) {
        json_data <- `dataset`$toJSON()
        json_data$type <- gsub('"', '', json_data$type)
        local_var_body <- jsonlite::toJSON(json_data, auto_unbox = TRUE, digits = NA)
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/models/{modelId}/predict"
      if (!missing(`model_id`)) {
        local_var_url_path <- gsub("\\{modelId\\}", URLencode(as.character(`model_id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "POST",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        return(local_var_resp)
        
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
        print(paste0("Error, status code ", local_var_resp$status_code))
        return(local_var_resp)
        
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
        print(paste0("API client error, status code ", local_var_resp$status_code))
        return(local_var_resp)
        
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        
        print(paste0("API server error, status code ", local_var_resp$status_code))
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },
    
    #' @description
    #' Predict using CSV with Model
    #'
    #' @param model_id The ID of the model to use for prediction
    #' @param dataset_csv the dataset csv
    #' @param ... Other optional arguments
    #'
    #' @return void
    PredictWithModelCSV = function(model_id, dataset_csv, ...) {
      local_var_response <- self$PredictWithModelCSVWithHttpInfo(model_id, dataset_csv, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Predict using CSV with Model
    #'
    #' @param model_id The ID of the model to use for prediction
    #' @param dataset_csv the dataset csv
    #' @param ... Other optional arguments
    #'
    #' @return API response (void) with additional information such as HTTP status code, headers
    PredictWithModelCSVWithHttpInfo = function(model_id, dataset_csv, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`model_id`)) {
        stop("Missing required parameter `model_id`.")
      }
      
      if (missing(`dataset_csv`)) {
        stop("Missing required parameter `dataset_csv`.")
      }
      
      
      
      if (!is.null(`dataset_csv`)) {
        local_var_body <- `dataset_csv`$toJSONString()
      } else {
        body <- NULL
      }
      
      local_var_url_path <- "/v1/models/{modelId}/predict/csv"
      if (!missing(`model_id`)) {
        local_var_url_path <- gsub("\\{modelId\\}", URLencode(as.character(`model_id`), reserved = TRUE), local_var_url_path)
      }
      
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list()
      
      # The Content-Type representation header
      local_var_content_types <- list("application/json")
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "POST",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        local_var_resp$content <- NULL
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    
    #' @description
    #' Search for models
    #'
    #' @param query the query
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return GetModels200Response
    SearchModels = function(query, page = 0, size = 10, data_file = NULL, ...) {
      local_var_response <- self$SearchModelsWithHttpInfo(query, page, size, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    
    #' @description
    #' Search for models
    #'
    #' @param query the query
    #' @param page (optional) No description (default value: 0)
    #' @param size (optional) No description (default value: 10)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (GetModels200Response) with additional information such as HTTP status code, headers
    SearchModelsWithHttpInfo = function(query, page = 0, size = 10, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE
      
      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }
      
      
      
      
      query_params[["query"]] <- `query`
      
      query_params[["page"]] <- `page`
      
      query_params[["size"]] <- `size`
      
      local_var_url_path <- "/v1/models/search"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }
      
      # The Accept request HTTP header
      local_var_accepts <- list("application/json")
      
      # The Content-Type representation header
      local_var_content_types <- list()
      
      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                                method = "GET",
                                                query_params = query_params,
                                                header_params = header_params,
                                                form_params = form_params,
                                                file_params = file_params,
                                                accepts = local_var_accepts,
                                                content_types = local_var_content_types,
                                                body = local_var_body,
                                                is_oauth = is_oauth,
                                                oauth_scopes = oauth_scopes,
                                                ...)
      
      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }
        
        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response_as_text(), "GetModels200Response", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)


#' Create a new ModelSummary
#'
#' @description
#' ModelSummary Class
#'
#' @docType class
#' @title ModelSummary
#' @description ModelSummary Class
#' @format An \code{R6Class} generator object
#' @field id  integer
#' @field name  character
#' @field visibility  \link{ModelVisibility}
#' @field description  character [optional]
#' @field creator  \link{User} [optional]
#' @field type  \link{ModelType}
#' @field dependentFeaturesLength  integer [optional]
#' @field independentFeaturesLength  integer [optional]
#' @field sharedWithOrganizations  list(\link{OrganizationSummary})
#' @field createdAt The date and time when the feature was created. character
#' @field updatedAt The date and time when the feature was last updated. character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
ModelSummary <- R6::R6Class(
  "ModelSummary",
  public = list(
    `id` = NULL,
    `name` = NULL,
    `visibility` = NULL,
    `description` = NULL,
    `creator` = NULL,
    `type` = NULL,
    `dependentFeaturesLength` = NULL,
    `independentFeaturesLength` = NULL,
    `sharedWithOrganizations` = NULL,
    `createdAt` = NULL,
    `updatedAt` = NULL,
    
    #' @description
    #' Initialize a new ModelSummary class.
    #'
    #' @param id id
    #' @param name name
    #' @param visibility visibility
    #' @param type type
    #' @param sharedWithOrganizations sharedWithOrganizations
    #' @param createdAt The date and time when the feature was created.
    #' @param description description
    #' @param creator creator
    #' @param dependentFeaturesLength dependentFeaturesLength
    #' @param independentFeaturesLength independentFeaturesLength
    #' @param updatedAt The date and time when the feature was last updated.
    #' @param ... Other optional arguments.
    initialize = function(`id`, `name`, `visibility`, `type`, `sharedWithOrganizations`, `createdAt`, `description` = NULL, `creator` = NULL, `dependentFeaturesLength` = NULL, `independentFeaturesLength` = NULL, `updatedAt` = NULL, ...) {
      if (!missing(`id`)) {
        if (!(is.numeric(`id`) && length(`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", `id`))
        }
        self$`id` <- `id`
      }
      if (!missing(`name`)) {
        if (!(is.character(`name`) && length(`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", `name`))
        }
        self$`name` <- `name`
      }
      if (!missing(`visibility`)) {
        if (!(`visibility` %in% c())) {
          stop(paste("Error! \"", `visibility`, "\" cannot be assigned to `visibility`. Must be .", sep = ""))
        }
        stopifnot(R6::is.R6(`visibility`))
        self$`visibility` <- `visibility`
      }
      if (!missing(`type`)) {
        if (!(`type` %in% c())) {
          stop(paste("Error! \"", `type`, "\" cannot be assigned to `type`. Must be .", sep = ""))
        }
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
      if (!missing(`sharedWithOrganizations`)) {
        stopifnot(is.vector(`sharedWithOrganizations`), length(`sharedWithOrganizations`) != 0)
        sapply(`sharedWithOrganizations`, function(x) stopifnot(R6::is.R6(x)))
        self$`sharedWithOrganizations` <- `sharedWithOrganizations`
      }
      if (!missing(`createdAt`)) {
        if (!(is.character(`createdAt`) && length(`createdAt`) == 1)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", `createdAt`))
        }
        self$`createdAt` <- `createdAt`
      }
      if (!is.null(`description`)) {
        if (!(is.character(`description`) && length(`description`) == 1)) {
          stop(paste("Error! Invalid data for `description`. Must be a string:", `description`))
        }
        self$`description` <- `description`
      }
      if (!is.null(`creator`)) {
        stopifnot(R6::is.R6(`creator`))
        self$`creator` <- `creator`
      }
      if (!is.null(`dependentFeaturesLength`)) {
        if (!(is.numeric(`dependentFeaturesLength`) && length(`dependentFeaturesLength`) == 1)) {
          stop(paste("Error! Invalid data for `dependentFeaturesLength`. Must be an integer:", `dependentFeaturesLength`))
        }
        self$`dependentFeaturesLength` <- `dependentFeaturesLength`
      }
      if (!is.null(`independentFeaturesLength`)) {
        if (!(is.numeric(`independentFeaturesLength`) && length(`independentFeaturesLength`) == 1)) {
          stop(paste("Error! Invalid data for `independentFeaturesLength`. Must be an integer:", `independentFeaturesLength`))
        }
        self$`independentFeaturesLength` <- `independentFeaturesLength`
      }
      if (!is.null(`updatedAt`)) {
        if (!is.character(`updatedAt`)) {
          stop(paste("Error! Invalid data for `updatedAt`. Must be a string:", `updatedAt`))
        }
        self$`updatedAt` <- `updatedAt`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelSummary in JSON format
    toJSON = function() {
      ModelSummaryObject <- list()
      if (!is.null(self$`id`)) {
        ModelSummaryObject[["id"]] <-
          self$`id`
      }
      if (!is.null(self$`name`)) {
        ModelSummaryObject[["name"]] <-
          self$`name`
      }
      if (!is.null(self$`visibility`)) {
        ModelSummaryObject[["visibility"]] <-
          self$`visibility`$toJSON()
      }
      if (!is.null(self$`description`)) {
        ModelSummaryObject[["description"]] <-
          self$`description`
      }
      if (!is.null(self$`creator`)) {
        ModelSummaryObject[["creator"]] <-
          self$`creator`$toJSON()
      }
      if (!is.null(self$`type`)) {
        ModelSummaryObject[["type"]] <-
          self$`type`$toJSON()
      }
      if (!is.null(self$`dependentFeaturesLength`)) {
        ModelSummaryObject[["dependentFeaturesLength"]] <-
          self$`dependentFeaturesLength`
      }
      if (!is.null(self$`independentFeaturesLength`)) {
        ModelSummaryObject[["independentFeaturesLength"]] <-
          self$`independentFeaturesLength`
      }
      if (!is.null(self$`sharedWithOrganizations`)) {
        ModelSummaryObject[["sharedWithOrganizations"]] <-
          lapply(self$`sharedWithOrganizations`, function(x) x$toJSON())
      }
      if (!is.null(self$`createdAt`)) {
        ModelSummaryObject[["createdAt"]] <-
          self$`createdAt`
      }
      if (!is.null(self$`updatedAt`)) {
        ModelSummaryObject[["updatedAt"]] <-
          self$`updatedAt`
      }
      ModelSummaryObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelSummary
    #'
    #' @param input_json the JSON input
    #' @return the instance of ModelSummary
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`id`)) {
        self$`id` <- this_object$`id`
      }
      if (!is.null(this_object$`name`)) {
        self$`name` <- this_object$`name`
      }
      if (!is.null(this_object$`visibility`)) {
        `visibility_object` <- ModelVisibility$new()
        `visibility_object`$fromJSON(jsonlite::toJSON(this_object$`visibility`, auto_unbox = TRUE, digits = NA))
        self$`visibility` <- `visibility_object`
      }
      if (!is.null(this_object$`description`)) {
        self$`description` <- this_object$`description`
      }
      if (!is.null(this_object$`creator`)) {
        `creator_object` <- User$new()
        `creator_object`$fromJSON(jsonlite::toJSON(this_object$`creator`, auto_unbox = TRUE, digits = NA))
        self$`creator` <- `creator_object`
      }
      if (!is.null(this_object$`type`)) {
        `type_object` <- ModelType$new()
        `type_object`$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
        self$`type` <- `type_object`
      }
      if (!is.null(this_object$`dependentFeaturesLength`)) {
        self$`dependentFeaturesLength` <- this_object$`dependentFeaturesLength`
      }
      if (!is.null(this_object$`independentFeaturesLength`)) {
        self$`independentFeaturesLength` <- this_object$`independentFeaturesLength`
      }
      if (!is.null(this_object$`sharedWithOrganizations`)) {
        self$`sharedWithOrganizations` <- ApiClient$new()$deserializeObj(this_object$`sharedWithOrganizations`, "array[OrganizationSummary]", loadNamespace("openapi"))
      }
      if (!is.null(this_object$`createdAt`)) {
        self$`createdAt` <- this_object$`createdAt`
      }
      if (!is.null(this_object$`updatedAt`)) {
        self$`updatedAt` <- this_object$`updatedAt`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelSummary in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`id`)) {
          sprintf(
            '"id":
            %d
                    ',
            self$`id`
          )
        },
        if (!is.null(self$`name`)) {
          sprintf(
            '"name":
            "%s"
                    ',
            self$`name`
          )
        },
        if (!is.null(self$`visibility`)) {
          sprintf(
            '"visibility":
          %s
          ',
            jsonlite::toJSON(self$`visibility`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`description`)) {
          sprintf(
            '"description":
            "%s"
                    ',
            self$`description`
          )
        },
        if (!is.null(self$`creator`)) {
          sprintf(
            '"creator":
          %s
          ',
            jsonlite::toJSON(self$`creator`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`type`)) {
          sprintf(
            '"type":
          %s
          ',
            jsonlite::toJSON(self$`type`$toJSON(), auto_unbox = TRUE, digits = NA)
          )
        },
        if (!is.null(self$`dependentFeaturesLength`)) {
          sprintf(
            '"dependentFeaturesLength":
            %d
                    ',
            self$`dependentFeaturesLength`
          )
        },
        if (!is.null(self$`independentFeaturesLength`)) {
          sprintf(
            '"independentFeaturesLength":
            %d
                    ',
            self$`independentFeaturesLength`
          )
        },
        if (!is.null(self$`sharedWithOrganizations`)) {
          sprintf(
            '"sharedWithOrganizations":
          [%s]
',
            paste(sapply(self$`sharedWithOrganizations`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox = TRUE, digits = NA)), collapse = ",")
          )
        },
        if (!is.null(self$`createdAt`)) {
          sprintf(
            '"createdAt":
            "%s"
                    ',
            self$`createdAt`
          )
        },
        if (!is.null(self$`updatedAt`)) {
          sprintf(
            '"updatedAt":
            "%s"
                    ',
            self$`updatedAt`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelSummary
    #'
    #' @param input_json the JSON input
    #' @return the instance of ModelSummary
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`id` <- this_object$`id`
      self$`name` <- this_object$`name`
      self$`visibility` <- ModelVisibility$new()$fromJSON(jsonlite::toJSON(this_object$`visibility`, auto_unbox = TRUE, digits = NA))
      self$`description` <- this_object$`description`
      self$`creator` <- User$new()$fromJSON(jsonlite::toJSON(this_object$`creator`, auto_unbox = TRUE, digits = NA))
      self$`type` <- ModelType$new()$fromJSON(jsonlite::toJSON(this_object$`type`, auto_unbox = TRUE, digits = NA))
      self$`dependentFeaturesLength` <- this_object$`dependentFeaturesLength`
      self$`independentFeaturesLength` <- this_object$`independentFeaturesLength`
      self$`sharedWithOrganizations` <- ApiClient$new()$deserializeObj(this_object$`sharedWithOrganizations`, "array[OrganizationSummary]", loadNamespace("openapi"))
      self$`createdAt` <- this_object$`createdAt`
      self$`updatedAt` <- this_object$`updatedAt`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to ModelSummary and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
      # check the required field `id`
      if (!is.null(input_json$`id`)) {
        if (!(is.numeric(input_json$`id`) && length(input_json$`id`) == 1)) {
          stop(paste("Error! Invalid data for `id`. Must be an integer:", input_json$`id`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `id` is missing."))
      }
      # check the required field `name`
      if (!is.null(input_json$`name`)) {
        if (!(is.character(input_json$`name`) && length(input_json$`name`) == 1)) {
          stop(paste("Error! Invalid data for `name`. Must be a string:", input_json$`name`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `name` is missing."))
      }
      # check the required field `visibility`
      if (!is.null(input_json$`visibility`)) {
        stopifnot(R6::is.R6(input_json$`visibility`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `visibility` is missing."))
      }
      # check the required field `type`
      if (!is.null(input_json$`type`)) {
        stopifnot(R6::is.R6(input_json$`type`))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `type` is missing."))
      }
      # check the required field `sharedWithOrganizations`
      if (!is.null(input_json$`sharedWithOrganizations`)) {
        stopifnot(is.vector(input_json$`sharedWithOrganizations`), length(input_json$`sharedWithOrganizations`) != 0)
        tmp <- sapply(input_json$`sharedWithOrganizations`, function(x) stopifnot(R6::is.R6(x)))
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `sharedWithOrganizations` is missing."))
      }
      # check the required field `createdAt`
      if (!is.null(input_json$`createdAt`)) {
        if (!(is.character(input_json$`createdAt`) && length(input_json$`createdAt`) == 1)) {
          stop(paste("Error! Invalid data for `createdAt`. Must be a string:", input_json$`createdAt`))
        }
      } else {
        stop(paste("The JSON input `", input, "` is invalid for ModelSummary: the required field `createdAt` is missing."))
      }
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of ModelSummary
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      # check if the required `id` is null
      if (is.null(self$`id`)) {
        return(FALSE)
      }
      
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        return(FALSE)
      }
      
      if (nchar(self$`name`) > 255) {
        return(FALSE)
      }
      if (nchar(self$`name`) < 3) {
        return(FALSE)
      }
      
      # check if the required `visibility` is null
      if (is.null(self$`visibility`)) {
        return(FALSE)
      }
      
      if (nchar(self$`description`) > 50000) {
        return(FALSE)
      }
      if (nchar(self$`description`) < 3) {
        return(FALSE)
      }
      
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        return(FALSE)
      }
      
      # check if the required `sharedWithOrganizations` is null
      if (is.null(self$`sharedWithOrganizations`)) {
        return(FALSE)
      }
      
      # check if the required `createdAt` is null
      if (is.null(self$`createdAt`)) {
        return(FALSE)
      }
      
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      # check if the required `id` is null
      if (is.null(self$`id`)) {
        invalid_fields["id"] <- "Non-nullable required field `id` cannot be null."
      }
      
      # check if the required `name` is null
      if (is.null(self$`name`)) {
        invalid_fields["name"] <- "Non-nullable required field `name` cannot be null."
      }
      
      if (nchar(self$`name`) > 255) {
        invalid_fields["name"] <- "Invalid length for `name`, must be smaller than or equal to 255."
      }
      if (nchar(self$`name`) < 3) {
        invalid_fields["name"] <- "Invalid length for `name`, must be bigger than or equal to 3."
      }
      
      # check if the required `visibility` is null
      if (is.null(self$`visibility`)) {
        invalid_fields["visibility"] <- "Non-nullable required field `visibility` cannot be null."
      }
      
      if (nchar(self$`description`) > 50000) {
        invalid_fields["description"] <- "Invalid length for `description`, must be smaller than or equal to 50000."
      }
      if (nchar(self$`description`) < 3) {
        invalid_fields["description"] <- "Invalid length for `description`, must be bigger than or equal to 3."
      }
      
      # check if the required `type` is null
      if (is.null(self$`type`)) {
        invalid_fields["type"] <- "Non-nullable required field `type` cannot be null."
      }
      
      # check if the required `sharedWithOrganizations` is null
      if (is.null(self$`sharedWithOrganizations`)) {
        invalid_fields["sharedWithOrganizations"] <- "Non-nullable required field `sharedWithOrganizations` cannot be null."
      }
      
      # check if the required `createdAt` is null
      if (is.null(self$`createdAt`)) {
        invalid_fields["createdAt"] <- "Non-nullable required field `createdAt` cannot be null."
      }
      
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# ModelSummary$unlock()
#
## Below is an example to define the print function
# ModelSummary$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# ModelSummary$lock()

#' @docType class
#' @title ModelTask
#' @description ModelTask Class
#' @format An \code{R6Class} generator object
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
ModelTask <- R6::R6Class(
  "ModelTask",
  public = list(
    
    #' @description
    #' Initialize a new ModelTask class.
    #'
    #' @param ... Optional arguments.
    initialize = function(...) {
      local.optional.var <- list(...)
      val <- unlist(local.optional.var)
      enumvec <- .parse_ModelTask()
      
      if (length(val) == 0L) {
        val = "DUMMY_ENUM"
      } else {
        stopifnot(length(val) == 1L)
      }
      
      if (!val %in% enumvec) {
        if (!(val=="DUMMY_ENUM")) {
          stop("Use one of the valid values: ",
               paste0(enumvec, collapse = ", "))
        }
        warning("Initializing ModelTask with DUMMY_ENUM. Use one of the valid values: ",
                paste0(enumvec, collapse = ", "),
                ". If you did not manually initialize ModelTask, this may already be overwritten by an enum loaded from a JSON config.")
      }
      private$value <- val
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelTask in JSON format
    toJSON = function() {
      jsonlite::toJSON(private$value, auto_unbox = TRUE)
    },
    
    #' @description
    #' Get string value
    #'
    #' @return string
    getValue = function() {
      private$value
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelTask
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelTask
    fromJSON = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelTask in JSON format
    toJSONString = function() {
      as.character(jsonlite::toJSON(private$value,
                                    auto_unbox = TRUE))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelTask
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelTask
    fromJSONString = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    }
  ),
  private = list(
    value = NULL
  )
)

# add to utils.R
.parse_ModelTask <- function(vals) {
  res <- gsub("^\\[|\\]$", "", "[REGRESSION, BINARY_CLASSIFICATION, MULTICLASS_CLASSIFICATION]")
  unlist(strsplit(res, ", "))
}


#' @docType class
#' @title ModelType
#' @description ModelType Class
#' @format An \code{R6Class} generator object
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
ModelType <- R6::R6Class(
  "ModelType",
  public = list(
    
    #' @description
    #' Initialize a new ModelType class.
    #'
    #' @param ... Optional arguments.
    initialize = function(...) {
      local.optional.var <- list(...)
      val <- unlist(local.optional.var)
      enumvec <- .parse_ModelType()
      
      if (length(val) == 0L) {
        val = "DUMMY_ENUM"
      } else {
        stopifnot(length(val) == 1L)
      }
      
      if (!val %in% enumvec) {
        if (!(val=="DUMMY_ENUM")) {
          stop("Use one of the valid values: ",
               paste0(enumvec, collapse = ", "))
        }
        warning("Initializing ModelType with DUMMY_ENUM. Use one of the valid values: ",
                paste0(enumvec, collapse = ", "),
                ". If you did not manually initialize ModelType, this may already be overwritten by an enum loaded from a JSON config.")
      }
      private$value <- val
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelType in JSON format
    toJSON = function() {
      jsonlite::toJSON(private$value, auto_unbox = TRUE)
    },
    
    #' @description
    #' Get string value
    #'
    #' @return string
    getValue = function() {
      private$value
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelType
    fromJSON = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    },
    
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelType in JSON format
    toJSONString = function() {
      as.character(jsonlite::toJSON(private$value,
                                    auto_unbox = TRUE))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelType
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelType
    fromJSONString = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    }
  ),
  private = list(
    value = NULL
  )
)

# add to utils.R
.parse_ModelType <- function(vals) {
  res <- gsub("^\\[|\\]$", "", "[SKLEARN, TORCH_ONNX, TORCHSCRIPT, R_BNLEARN_DISCRETE, R_CARET, R_GBM, R_NAIVE_BAYES, R_PBPK, R_RF, R_RPART, R_SVM, R_TREE_CLASS, R_TREE_REGR, QSAR_TOOLBOX_CALCULATOR, QSAR_TOOLBOX_QSAR_MODEL, QSAR_TOOLBOX_PROFILER]")
  unlist(strsplit(res, ", "))
}

#' @docType class
#' @title ModelVisibility
#' @description ModelVisibility Class
#' @format An \code{R6Class} generator object
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
ModelVisibility <- R6::R6Class(
  "ModelVisibility",
  public = list(
    
    #' @description
    #' Initialize a new ModelVisibility class.
    #'
    #' @param ... Optional arguments.
    initialize = function(...) {
      local.optional.var <- list(...)
      val <- unlist(local.optional.var)
      enumvec <- .parse_ModelVisibility()
      
      if (length(val) == 0L) {
        val = "DUMMY_ENUM"
      } else {
        stopifnot(length(val) == 1L)
      }
      
      if (!val %in% enumvec) {
        if (!(val=="DUMMY_ENUM")) {
          stop("Use one of the valid values: ",
               paste0(enumvec, collapse = ", "))
        }
        warning("Initializing ModelVisibility with DUMMY_ENUM. Use one of the valid values: ",
                paste0(enumvec, collapse = ", "),
                ". If you did not manually initialize ModelVisibility, this may already be overwritten by an enum loaded from a JSON config.")
      }
      private$value <- val
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelVisibility in JSON format
    toJSON = function() {
      jsonlite::toJSON(private$value, auto_unbox = TRUE)
    },
    #' @description
    #' Get string value
    #'
    #' @return string
    getValue = function() {
      private$value
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelVisibility
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelVisibility
    fromJSON = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return ModelVisibility in JSON format
    toJSONString = function() {
      as.character(jsonlite::toJSON(private$value,
                                    auto_unbox = TRUE))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of ModelVisibility
    #'
    #' @param input_json the JSON input
    #'
    #' @return the instance of ModelVisibility
    fromJSONString = function(input_json) {
      private$value <- jsonlite::fromJSON(input_json,
                                          simplifyVector = FALSE)
      self
    }
  ),
  private = list(
    value = NULL
  )
)

# add to utils.R
.parse_ModelVisibility <- function(vals) {
  res <- gsub("^\\[|\\]$", "", "[PUBLIC, ORG_SHARED, PRIVATE]")
  unlist(strsplit(res, ", "))
}


#' Create a new RPbpkConfig
#'
#' @description
#' Configuration for the R PBPK models
#'
#' @docType class
#' @title RPbpkConfig
#' @description RPbpkConfig Class
#' @format An \code{R6Class} generator object
#' @field odeSolver  character [optional]
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @keywords internal
#' @noRd
RPbpkConfig <- R6::R6Class(
  "RPbpkConfig",
  public = list(
    `odeSolver` = NULL,
    
    #' @description
    #' Initialize a new RPbpkConfig class.
    #'
    #' @param odeSolver odeSolver
    #' @param ... Other optional arguments.
    initialize = function(`odeSolver` = NULL, ...) {
      if (!is.null(`odeSolver`)) {
        if (!(is.character(`odeSolver`) && length(`odeSolver`) == 1)) {
          stop(paste("Error! Invalid data for `odeSolver`. Must be a string:", `odeSolver`))
        }
        self$`odeSolver` <- `odeSolver`
      }
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return RPbpkConfig in JSON format
    toJSON = function() {
      RPbpkConfigObject <- list()
      if (!is.null(self$`odeSolver`)) {
        RPbpkConfigObject[["odeSolver"]] <-
          self$`odeSolver`
      }
      RPbpkConfigObject
    },
    
    #' @description
    #' Deserialize JSON string into an instance of RPbpkConfig
    #'
    #' @param input_json the JSON input
    #' @return the instance of RPbpkConfig
    fromJSON = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      if (!is.null(this_object$`odeSolver`)) {
        self$`odeSolver` <- this_object$`odeSolver`
      }
      self
    },
    
    #' @description
    #' To JSON String
    #'
    #' @return RPbpkConfig in JSON format
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`odeSolver`)) {
          sprintf(
            '"odeSolver":
            "%s"
                    ',
            self$`odeSolver`
          )
        }
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      json_string <- as.character(jsonlite::minify(paste("{", jsoncontent, "}", sep = "")))
    },
    
    #' @description
    #' Deserialize JSON string into an instance of RPbpkConfig
    #'
    #' @param input_json the JSON input
    #' @return the instance of RPbpkConfig
    fromJSONString = function(input_json) {
      this_object <- jsonlite::fromJSON(input_json)
      self$`odeSolver` <- this_object$`odeSolver`
      self
    },
    
    #' @description
    #' Validate JSON input with respect to RPbpkConfig and throw an exception if invalid
    #'
    #' @param input the JSON input
    validateJSON = function(input) {
      input_json <- jsonlite::fromJSON(input)
    },
    
    #' @description
    #' To string (JSON format)
    #'
    #' @return String representation of RPbpkConfig
    toString = function() {
      self$toJSONString()
    },
    
    #' @description
    #' Return true if the values in all fields are valid.
    #'
    #' @return true if the values in all fields are valid.
    isValid = function() {
      TRUE
    },
    
    #' @description
    #' Return a list of invalid fields (if any).
    #'
    #' @return A list of invalid fields (if any).
    getInvalidFields = function() {
      invalid_fields <- list()
      invalid_fields
    },
    
    #' @description
    #' Print the object
    print = function() {
      print(jsonlite::prettify(self$toJSONString()))
      invisible(self)
    }
  ),
  # Lock the class to prevent modifications to the method or field
  lock_class = TRUE
)
## Uncomment below to unlock the class to allow modifications of the method or field
# RPbpkConfig$unlock()
#
## Below is an example to define the print function
# RPbpkConfig$set("public", "print", function(...) {
#   print(jsonlite::prettify(self$toJSONString()))
#   invisible(self)
# })
## Uncomment below to lock the class to prevent modifications to the method or field
# RPbpkConfig$lock()

